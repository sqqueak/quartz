{"/":{"title":"emilyyao.me","content":"\n# hey, it's squeak!\nWelcome to my pothole on the Internet. I'm Emily! My nickname is \"*squeak*\" ‚Äî from which most of my usernames on the web are derived. I'm currently an undergraduate student at UW-Madison studying computer science, mathematics, and economics. \n\nMy main hobby is puzzle-solving, which is where all my other interests stem from. I particularly enjoy competitive coding, among other computer science topics such as [computer networks](/ece537), image processing, robotics, and [low-level computing](https://store.steampowered.com/app/370360/TIS100/). In terms of math, my favorite subject is combinatorics, or more generally, probability theory. In my free time, I like [reading](https://thebookerprizes.com/the-booker-library/books), playing poker, and listening to [video game music](https://youtu.be/HL9_xm5HwrE).\n\nI like meeting interesting people -- if you want to say hi or grab lunch with me, send an email at `hello at emilyyao dot me`! If you're on campus, feel free to drop by during my [office hours](https://www.upl.cs.wisc.edu/hours.html) at the Undergraduate Projects Lab!\n\n\u003c!-- # projects...\n- Split wireless Lily58 Pro keyboard\n- [Flipper zero](https://flipperzero.one/)\n- Concept maps similar to [this](https://live.staticflickr.com/272/32264483720_c51bdde679_b.jpg)\n    - TCP/IP\n    - heaps n' caches\n- [Motion canvas](https://motioncanvas.io/) for math animations\n- [micromouse](https://www.youtube.com/watch?v=ZMQbHMgK2rw) --\u003e\n\n# pages\n[academics](/academics) -- classes and other things I've been involved in  \n[network analysis](/ece537) -- summary + reflection about a computer networks project  \n[project archive](/projects) -- writing about stuff I'm working on\n","lastmodified":"2023-08-24T05:02:02.307071884Z","tags":[]},"/2022-sea1":{"title":"2022 SEA #1","content":"## motivation\nI've always wanted to document my growth over a period of time to see what I can accomplish on my own. This summer is an ideal place to start -- just after high school and before college, where I have enough agency to achieve my goals, without too much academic stress. I'm drawing motivation from this saying: \n\n\u003e Most people overestimate what they can do in a day, but underestimate what they can do in a year.\n\nMy goals are the following:\n- Learn about topics that I think I would enjoy\n- Work on some small projects\n- Build healthy habits\n- Read more, write more\n- Enjoy that summer sun\n\nThey are vague on purpose -- I'll have plenty of options that accomplish these tasks without feeling restricted to a particular path.\n\n## starting point\n### online classes\nBefore the fall semester starts, I want to do a bit of learning on my own. For the most part, I'm going to be reviewing old classes (linear algebra, data structures / algorithms) and exploring new classes (discrete math, artificial intelligence, signals and systems). This is for me to \"test the waters\" and try out things that are interesting to me.\n\n### cool projects\nI'm interested in making something for 3Blue1Brown's [Summer of Math Exposition #2 (SoME2)](https://youtu.be/hZuYICAEN9Y). I'm not particularly sure what knowledge I have to offer but I'm planning on something within the computer science or signal processing realm. \n\nI've also been interested in cybersecurity for the past few months, but never got around to actually learning more about it. Since I have more time now, I want to take advantage of some resources like [HackTheBox](https://hackthebox.com), [OverTheWire: Wargames](https://overthewire.org/wargames/), the [DEF CON CTF archive](https://archive.ooo/) to help me learn more. At the beginning of this year, my goal was to participate in the DEF CON 30 CTF qualifiers, but that has since passed -- my new goal is to take a shot at next year's qualifiers, but we'll see about that...\n\nAmong other things, I want to clean up my website better and get my wiki space set up.\n\n## plan\nMy next update will be in two weeks. For the most part, I want to see where things will take me, so I don't really have a concrete schedule.","lastmodified":"2023-08-24T05:02:02.307071884Z","tags":[]},"/2022-sea2":{"title":"2022 SEA #2","content":"## recap\nI made a [post](/2022-sea1) two weeks ago where I wrote about what I wanted to accomplish in my free time this summer. This is my first progress update.\n\nMy focus has primarily been on settling into a good routine where I can balance work and learning in my downtime. I teach summer camps in the morning which has helped me build a solid morning routine. I have plenty of free time in the afternoons, which I've been trying to put towards doing something useful.\n\n## progress\n### academics\nHistorically, I don't have a good track record when it comes to self-paced online courses -- I struggle a lot with finding an interesting yet not-too-difficult class. So far I've tried and dropped Caltech's [Learning From Data](https://work.caltech.edu/telecourse) course because I didn't understand how to do the homeworks -- the answers were in Python, and I don't know Python. I also gave MIT's [18.06SC: Linear Algebra](https://openlearninglibrary.mit.edu/courses/course-v1:OCW+18.06SC+2T2019/about) a shot, but it's moving along very slowly. I think my hesitancy with this class comes from how I'm not confident at writing proofs. While I enjoy Gilbert Strang's lectures, I blank when it comes to applying new concepts on my own.\n\nGoing back to how I don't know Python: it's been on my todo list for a long time. I never got around to actually *learning* Python, and most of my prior experience came from doing beginner [Advent of Code](https://adventofcode.com/) problems. I did find a course that I've been working through [(CS 220 from UW-Madison)](http://msyamkumar.com/cs220/s20/schedule.html) and I'm about 1/3 of the way through. This has been my main focus for the past week as I've settled into this whole summer exploration thing.\n\n### cybersecurity\nLast week I managed to set up Kali Linux on my laptop after a bit of fiddling around. I'm not sure what I intend to do with it -- so far I've just been trying out the [Linux Fundamentals](https://academy.hackthebox.com/course/preview/linux-fundamentals) course on [HTB Academy](https://academy.hackthebox.com/). I want to get more familiar with using terminal and other command line tools. I also plan to finish a cybersecurity certificate I started a long time ago.\n\n### website\nAfter my last post, I spent a while working on my wiki website which is live now at [wiki.emilyyao.me](https://wiki.emilyyao.me). There are still a few things I need to work out (such as the side TOC being wonky on mobile) but it's a good start. I want to use somehow organize my notes and ramblings into comprehensive pages soon. This project will probably take a while until it is presentable. My main goal is to consistently update this during the school year and create something that can help other people, too.\n\n### \"Enjoy that summer sun\"\nI am sunburnt\n\n### misc\n- [my Taiko addiction](https://youtu.be/QbPj5vfprIQ)\n- Current reads: *Homegoing* by Yaa Gyasi; *Normal People* by Sally Rooney\n\n## plan\nMy first goal is to finish the CS 220 course which might take a bit longer than two weeks. I'd also like to finish both of the books I'm currently reading. Other side goals include: finishing the Linux course with HTB, cleaning up my old calculus notes on my wiki, and exiting my house to do something other than drive to work.","lastmodified":"2023-08-24T05:02:02.307071884Z","tags":[]},"/2022-sea3":{"title":"2022 SEA #3","content":"## recap\nThis is the second progress update (third post overall) in the series I started on what I want to accomplish this summer. Read my last post [here](/2022-sea2).\n\nLooking at my general goals from last time: I haven't made much progress with Linux nor learned anything cybersecurity related. I did mess around with installing Ubuntu using UTM but I ended up putting it on the backburner. For the most part, I've been working through CS 220.\n\n## progress\n### self-studying\nThis past week I finished [CS 220](/notes/cs220)! Learning Python this way has honestly been a joy -- the content at the beginning of the course came naturally since I had some coding experience, and the later topics (web scraping, databases) were fun to mess around with. I think I never had a chance to explore while learning Java because I was more focused on learning *how* to code, like learning syntax rules or what functions were, but now I can actually apply my knowledge. I want to get some more Python experience under my belt first, but my ultimate goal is to give Caltech's [Learning From Data](https://work.caltech.edu/telecourse) another shot.\n\nI was recommended UC Berkeley's [CS 61A](https://inst.eecs.berkeley.edu/~cs61a/fa21/) by a friend, which I've picked up this week. There are three classes in the sequence: 61A, 61B, and 61C -- 61B focuses on Java, which was something that I really wanted to review this summer. This is mostly because I want to compete in some AI programming games, like [Battlecode](https://battlecode.org) or the [Lux AI Challenge](https://lux-ai.org), and I want to brush up on Java before the competitions start.\n\nFinally, I started a discrete math course because I need it for a prerequisite for my actual college classes, and I heard the one at UW-Madison is a disaster. \n\n### reading\nI finished *Normal People* by Sally Rooney. The ending was equal parts dissatisfying, ambiguous, and fitting.\n\n### SoME2\nThe deadline for SoME2 is August 15th, which is in a month. I think I'm going to make something about [Dijkstra's algorithm](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm), which is my favorite algorithm (that I know of). As far as animation and visuals go, I'm only familar with frame-by-frame hand-drawn animation -- I'm going to play around with FlipaClip this week and see how that works out.\n\n### misc\n- Current reads: *Homegoing* by Yaa Gyasi, *At Night All Blood Is Black* by David Diop\n\n## plan\nI'm focusing on balancing my two courses with my work schedule this week. I also want to finish another book and fiddle with my websites some more. Side goals: ICSI certification, break out the tablet and animate a little, and back up my favorite JCS crime videos somewhere.","lastmodified":"2023-08-24T05:02:02.307071884Z","tags":[]},"/academics":{"title":"Classes","content":"# fall 2023\n‚úèÔ∏è \u0026nbsp; **CS 538:** Introduction to Theory and Design of Programming Languages  \n‚úèÔ∏è \u0026nbsp; **MATH 525:** Introduction to Linear Optimization  \n‚úèÔ∏è \u0026nbsp; **MATH 632 (*Honors*):** Introduction to Stochastic Processes  \n‚úèÔ∏è \u0026nbsp; **ECON 111 (*Honors Accelerated*):** Principles of Economics  \n‚úèÔ∏è \u0026nbsp; **HISTORY 143:** History of Race and Inequality in Urban America  \n‚úèÔ∏è \u0026nbsp; **MUSIC 113:** Music in Performance    \nüíº \u0026nbsp; System Administrator Intern `@` Morgridge Institute of Research\n\n# summer 2023 (self-studied)\n‚úèÔ∏è \u0026nbsp; **[6.S191](/notes/6-s191):** Introduction to Deep Learning `MIT`  \n‚úèÔ∏è \u0026nbsp; **[CS 544](/notes/cs544):** Introduction to Big Data Systems  \nüíº \u0026nbsp; Software Engineer Intern `@` Mandli Communications  \n\n# spring 2023\n‚úèÔ∏è \u0026nbsp; **CS 354:** Machine Organization and Programming  \n‚úèÔ∏è \u0026nbsp; **CS 540:** Introduction to Artificial Intelligence  \n‚úèÔ∏è \u0026nbsp; **CS 577:** Introduction to Algorithms  \n‚úèÔ∏è \u0026nbsp; **MATH 431:** Introduction to the Theory of Probability  \n‚úèÔ∏è \u0026nbsp; **MATH 521 (*Honors*):** Analysis I  \nüî¨ \u0026nbsp; Research project: Training and optimizing image generation models on custom datasets. \n\n# fall 2022\n‚úèÔ∏è \u0026nbsp; **CS 252:** Introduction to Computer Engineering  \n‚úèÔ∏è \u0026nbsp; **CS 475:** Introduction to Combinatorics  \n‚úèÔ∏è \u0026nbsp; **[ECE 537](/ece537):** Communication Networks  \n‚úèÔ∏è \u0026nbsp; **PHYSICS 201 (*Honors*):** General Physics  \n‚úèÔ∏è \u0026nbsp; **MSE 299:** Independent Study -- Machine Learning for Engineering Research. Learned basic ML workflow like cleaning data, training models, and optimization.\n\n# summer 2022 (self-studied)\n‚úèÔ∏è \u0026nbsp; **[CS 220](/notes/cs220):** Data Programming I  \n‚úèÔ∏è \u0026nbsp; **[CS 61A](/notes/cs61a):** Structure and Interpretation of Computer Programs `UC-Berkeley`  \n\n# previous\n‚úèÔ∏è \u0026nbsp; **CS 300:** Programming II (SU '20)  \n‚úèÔ∏è \u0026nbsp; **CS 400:** Programming III (FA '20)  \n‚úèÔ∏è \u0026nbsp; **ECE 203:** Signals, Information, and Computation (SU '21)  \n‚úèÔ∏è \u0026nbsp; **MATH 20804232:** Calculus \u0026 Analytic Geometry 2 (SU '21) `Madison College`  \n‚úèÔ∏è \u0026nbsp; **MATH 234:** Calculus - Functions of Several Variables (FA '21)  \n‚úèÔ∏è \u0026nbsp; **MATH 341 (*Honors Accelerated*):** Linear Algebra (SP '22)\n","lastmodified":"2023-08-24T05:02:02.307071884Z","tags":[]},"/ece537":{"title":"ECE 537","content":"(please refresh the page if the pdf doesn't load!)  \n[Project 2](http://emilyyao.me/report2.pdf): Analyzing TCP and UDP traffic behavior over wireless networks  \n[Project 3](http://emilyyao.me/report3.pdf): Estimating VBR/CBR based on packet capture\n\n\u003c!-- # context\n**ECE 537: Communication Networks**. Overview of the TCP/IP protocol stack. Large focus on application transport layer protocols, congestion detection and avoidance; brief introduction to wireless networks, addressing/routing/forwarding, and media streaming.  --\u003e\n\n# context\nDuring the Fall '22 semester, I took a class on the basics of computer networks. This page aims to provide insight on the motivation, process, and results for two of the larger assignments I completed during the course.\n\nFor each project, I was given a broad outline of a topic I should write a report on, and a list of steps on how to collect data for the report. For data collection, I learned to use a variety of tools, including but not limited to Wireshark, `iperf`, `rvictl`, Ubuntu, and [UTM](/utm-ubuntu) (for creating VMs on the new silicon chip Apple laptops). I wrote some Python scripts to make this process easier which can be found [here](https://github.com/heyitssqueak/pa2). \n\nI researched and collected data for a handful of different topics such as TCP/UDP transfer speed, TCP flavors, RTS/CTS signals, and variable/constant bitrates. An in-depth analysis and discussion of these topics can be found in their respective papers. \n\n\u003c!-- Although, since the papers are somewhat long and dense, I want to highlight a few things that I discovered that I thought were cool. --\u003e\n\n# reflection\n\u003c!-- My biggest takeaway from this project is adaptability. Most of the tools I mentioned are specific to this kind of work and I had zero experience using them coming into these projects. Learning my way around these tools as I was working on an actual project showed me that I could learn as I go. \n\nI also found it interesting to be able to to collect data and observe processes that are part of a larger, ongoing network. I've only ever ran code in isolated projects which had no interaction with the world. I had full control over the environment and when issues came up, I could locate and fix the problem. This project was more about using tools to watch a network run, and if anomalies came up in my data, I couldn't just locate to the source of the error and fix it, I had to find work arounds.  --\u003e\n\nThe part of the project that I found the most interesting was collecting data on the network in real time. A lot of the project-based assignments that I've come across are somewhat isolated -- you develop a small codebase on your own, and then it runs on your machine on a static and local copy of the data. While this is a great way to learn, I think it misses some aspects of the big picture. Analyzing the network data in real time was cool because it felt like my code was observing something far beyond itself. I have a lot of respect and admiration for the researchers who created the standards for these protocols to run efficiently on such a large scale.\n\nProject-wise, I believe that there is more to be done which could improve the quality of these reports. There are some siginificant errors in Project 2 which affected the average throughput calculations, and my measurements for TCP channels in Project 3 were outright wrong. In Project 2, I tried to mention possible sources of error and bias and how I would correct for it in the future. I think those ideas are a good starting point and I would definitely encorporate stricter rules on how I collect data and correct for biases if I were to do this again.\n\nThat being said, I don't believe I will revisit these projects as they are now. My primary takeaway from these reports was learning how to use Wireshark, understanding the packet/traffic flow graphs, and utilizing command line tools and scripts. Redoing these projects would not teach me as much as they did the first time around. However, I am interested in learning how to use a Raspberry Pi, and I recently learned that you can install Wireshark on a Pi. It could be an interesting thing to work on in the future, maybe as a long-term data collection project, but I'd have to get my hands on a Pi first...","lastmodified":"2023-08-24T05:02:02.307071884Z","tags":[]},"/notes/6-s191":{"title":"6.S191","content":"\n# introduction to deep learning\n- VISTA: synthesizing environments for autonomous vehicles to train in\n    - Don't have to send the vehicles out into the real world to train; can do so through simulation!\n- Artificial intelligence (AI): techniques that allow computers to mimic human behavior\n- Machine learning (ML): train a machine to make decisions based on a set of data, but not explicitly programming it to make decisions\n- Deep learning (DL): extracting patterns from neural networks to fill in the gaps\n    - Machine extracts core patterns, then applies it to new data\n        - This is as opposed to when humans hand pick and define correct and incorrect data and feed it into a machine to learn (ML)\n- **Perceptron**: a single neuron\n    - Composed of inputs, weights, a bias, nonlinear activation function, and summation\n    - Steps to get the output of a perceptron ($\\hat{y}$): \n        1. multiply inputs by weights  \n        2. sum  \n        3. add nonlinearity   \n![math representation of perceptron](/notes/image-2.png)\n- What is a **nonlinear function**? Why is it useful?\n    - What: a function that takes any real number and maps it to a specific range\n        - Example: the sigmoid function maps all numbers to be between [0, 1] using the function $g(z)=\\frac{1}{1+e^{-z}}$\n    - Why: introduce nonlinearity into the network\n![example of why nonlinear data is important](/notes/image-3.png)\n- Deep neural networks are just neural networks with many hidden layers\n- **Loss functions** tell the neural network how big of a mistake it made, given the predicted value and the true value\n- Loss optimization involves minimizing the loss value -- we want to find NN weights that will achieve this\n    - Gradient descent:\n        - For any point, we can compute the gradient of the loss function for that point, and tweak the value such that the loss value decreases\n        - Repeat this until convergence to the minimum value\n- **Backpropagation:** computing the weight of the node by applying the chain rule on the loss function from the output to the input\n![backpropagation example](/notes/image-4.png)\n- Training NNs in practice is difficult\n    - What is the learning rate? How do we set it?\n        - Small LRs converge slowly and occasionally get stuck in local minima\n        - Large LRs overshoot and diverge and the NN doesn't train\n        - The learning rate can be an algorithm that adapts to the landscape (possible weights)\n    - What are batches? Why are they useful?\n        - It's not feasible to compute the gradient over the entire dataset because the dataset is too large\n        - Take a small \"batch\" (sample) of the dataset and compute the gradient over that instead of the entire set or a single point\n        - Using mini-batches allows for smoother convergence and faster training (allows for parallelization per batch!!)\n    - What is overfitting? How do we correct for it?\n        - A model that has overfit to a dataset means it has followed training data too well and can't generalize to other datasets\n        ![types of fit](/notes/image-5.png)\n        - Regularization is used to help discourage overfitting and is introduced into the NN\n            - Dropout: randomly set some neurons to be 0\n            - Early stopping: stop training before the model is good enough to overfit\n            ![early stopping graph](/notes/image-7.png)\n- Summary:\n    - What is the perceptron? What are its parts? What is a nonlinear activation function and why is it useful?\n    - How do we get from a single perceptron to a NN? How does the NN learn? What is backpropagation and what is its relation to weight calculation?\n    - What are some techniques applied in practice that allow for NNs to be accurate?\n\n---\n\n# recurrent neural networks, transformers, and attention\n- Sequential data are when the points in the dataset depend on other points, for example, sound waves defining audio or a timeseries such as a stock market\n![types of sequential models](/notes/image-13.png)\n- For working with sequential data, we define recurrence relations $h_t$ for a time step $t$ which retains information about the state which the NN was in when it produced the output $\\hat{y}_t$ \n    - Since the state of the NN is tracked for each output, then our output now depends on the state, $\\hat{y}_t=f(x_t, h_{t-1})$\n- Formally, **recurrent neural networks (RNNs)** track state $h_t$ which is updated each time step\n    - Given an input vector, update the hidden state (which has its own weight matrix)\n    - Then combine the input's weight matrix and the hidden state's weight matrix with nonlinearity to get output\n    - Loss in calculated for each individual timestep and them combined into an overall loss value\n    - Backpropagation occurs through each individual timestep, then from the current time all the way to the beginning\n![RNN model example](/notes/image-10.png)\n- Issues with backpropagating in RNNs\n    - Computing the gradient wrt the initial input requires that you perform gradient calculations on many versions of the state weight matrix\n    - Exploding gradients \u003e gradient clipping\n        - Gradients keep increasing and get extremely large\n        - Scale back large gradients by clipping\n    - Vanishing gradients\n        - Harder time capturing long term dependencies because many small numbers are being multiplied together\n        1. Activation function tweaking\n        ![ReLU vs sigmoid](/notes/image-11.png)\n        2. Parameter initialization via setting weights to identity matrices\n        3. Gated cells: using gates to filter information per recurrent unit (LSTM)\n        ![LSTM example](/notes/image-12.png)\n- What should we keep in mind when designing models for sequences?\n    - Variable-length of the sequences\n    - Dependencies between data points that are distant from each other\n    - Maintaining order\n    - One set of weights can be applied to any timestep input and still work\n- Encoding language for NNs: transform words into vector representations\n    - One-hot embedding\n        1. Obtain a vocabulary (corpus)\n        2. Map each word to an index\n        3. A word is a vector of 0s with a 1 at the word's index\n    - Cons to one-hot embedding: the words have no meaning to each other \n    - Learned embedding: use a NN to learn an embedding\n- Limitations of RNNs in application\n    - Encoding bottlenecks: in the case of many-to-one models (sentiment classification), how do we encode all the text to just one single result without losing information?\n    - Slow: can't parallelize because every step depends on the previous one\n    - No long term memory\n- **Attention:** how can we eliminate the need for recurrence and improve on the above issues, but still analyze data in sequential order?\n    - Identify the most important features in the input\n        1. Encode position information (embedding)\n        2. Extract query, key, value for search -- what is the most important information related to my request?\n        3. Compute attention weighing -- compute pairwise similarity between each query and key\n            - How similar are any two features? \n            - Computed using the dot product between query and key, called the cosine similarity or the similarity metric\n        4. Extract features with high attention  \n![Alt text](/notes/image-17.png)\n![Alt text](/notes/image-18.png)\n- Summary:\n    - What are RNNs? What are its key features? What are they useful for?\n    - How do RNNs perform backpropagation and what are some major issues of backpropagating in RNNs? What are some downsides of RNNs?\n    - What is attention? What is its importance with relation to RNNs? Why is it important?\n\n---\n\n# convolutional neural networks\n\n\n\n\u003c!-- http://ruder.io/optimizing-gradient-descent/ --\u003e","lastmodified":"2023-08-24T05:02:02.331071971Z","tags":[]},"/notes/cs220":{"title":"CS 220","content":"Self-paced course taken summer '22, linked [here](https://www.msyamkumar.com/cs220/s20/syllabus.html). Introductory data science programming using Python -- teaches Python basics, programming fundamentals, and data science modules in Python. Texts used include Allen B. Downey's *Think Python, 2nd Edition* and Al Sweigart's *Automate the Boring Stuff*. Completed homework linked [here](https://github.com/heyitssqueak/classes/tree/master/cs220).\n\n# control flow\n\n## introduction\n- inputs: keyboard, mouse\n- outputs: monitor, speaker\n- devices attach to the computer via ‚Äúports‚Äù (USB)\n- motherboard: main circuit and connects to other components with sockets and slots\n- CPU, central processing unit\n    - runs code (receives input, sends output)\n    - runs on a clock, measured in Hz (ex. GHz is billions of ticks per second)\n    - high speed CPU ‚Üí hotter\n    - computers have multiple CPUs\n- RAM, random access memory\n    - short term data storage\n        - CPU sends to and from RAM\n    - ‚Äúvolatile‚Äù - lose data when computer is powered off\n    - one byte = one letter\n- storage drives\n    - HDD, hard disk drive\n        - inexpensive, moving parts, slow\n    - SSD, solid state drive\n        - expensive, no moving parts, fast\n    - stores data after computer shut down\n- network: an extension or built-in card to the motherboard\n    - NIC, network interface controller\n        - provides communication to other machines + internet\n    - wired = ethernet, wireless = wifi\n    - server: computer waits for incoming requests which it responds to\n    - client: program that sends requests to a server\n- jupyter notebook runs and displays results of py code without needing to run it yourself\n\n---\n\n## the terminal\n\n- you can connect to terminals located anywhere, such as connecting to a remote computer OR connecting to a personal computer\n- shell helps navigate to program and run\n- helpful shell commands    \n    - `pwd` get working directory ‚Üí current location\n    - `man` opens manual pages for command\n    - `\u003ctab\u003e` autocomplete\n    - `\u003cctrl-C\u003e` kill / exit\n    - `\u003cup arrow\u003e` last used command\n    - `\u003cctrl-R\u003e` search used commands\n    - `cd` open directory\n        - `cd ..` go up a directory\n        - `cd /` go to top directory\n    - `ls` lists contents of current directory\n    - `mkdir` makes new directory\n    - `echo` repeat or copy\n    - `cat` display contents of file\n    - `mv [original] [destination]` move files\n    - `cp [original] [destination]` copy files        \n- pathname: the location of your file (windows: includes drive letter, filename, extension‚Ä¶)\n    - absolute: always possible (complete path name to file)\n    - relative: with respect to current location\n    - working directory: current location\n    - `..` navigates up a directory\n    - `.` navigates into a directory\n- arguments are inputs that come after the call of the program name\n- use `\u003e` to redirect output to a new file\n- use `\u003e\u003e` to add output to a file\n\n---\n\n## programming\n\n- interpreter: a program that translates human-legible code into machine-legible code\n- editor: a program where you can write code\n- jupyter notebook mixes code with other things like images, tables, documentation, etc\n- ways to run python\n    - `python` interactive, denoted by `\u003e\u003e\u003e`\n    - `python [program name]` script\n    - `jupyter notebook` notebook\n- python uses order of operations to simplify equations (parentheses, exponents, m/d, a/s)\n    - negative and positive signs take precedence over m/d\n    - logic operators come after comparison operators which come after math operators\n![operator-diagram](/images/cs220/operator-precedence.png)\n- boolean operators\n    - AND: true when both conditions are true (t/t), false otherwise (t/f, f/t, f/f)\n    - OR: true when one condition is true (t/t, t/f, f/t), false otherwise (f/f)\n    - NOT: true when the condition is false\n        - evaluate: NOT(is it saturday?)\n            - if (is it saturday?) is true, then the expression is false, i.e., it IS saturday\n            - if (is it saturday?) is false, then the expression is true, i.e., it is NOT saturday\n\n### downey ch1: the way of the program\n\n- python uses symbols as *bitwise* operators and words as logic operators\n    - `and` `or` are logic operators\n    - `\u0026` `|` are bitwise operators\n        - convert arguments into binary before comparisons\n- common types: int, float, string, boolean\n- parsing is understanding structure and meaning in a language\n    - formal language: specifically designed languages (like mathematical or molecular notation); means exactly what it says, unambiguous, less redundant/more concise\n    - natural language: naturally-evolved language (like English); has idioms/metaphor, needs redundancy to make up for ambiguity\n\n---\n\n## variables and expressions\n\n- expressions are a mix of operators (logic, mathematical) and operands (values)\n    - an operand *could* be a variable which means it won‚Äôt be a fixed value\n    - `//` is the floor division operator: `x // y` is ‚Äúhow many times does `y` go into `x`?\n- assignments compute an expression and put the result in a variable ‚Äî assignment operator is `=`\n    - ex: `total = x+y` where `total` is the resultant variable; `x` and `y` are operands (and also variables); `x+y` is the expression\n- types of errors\n    - syntax error: the written code is wrong, Python won‚Äôt run, ex: `5 = x`, we can‚Äôt assign `x` to the number `5`\n    - runtime errors: something that crashes when we run the code, ex: `x = 5 / 0`, can‚Äôt divide by zero and will result in a `ZeroDivisionError`\n    - semantic (logic) error: the code runs but you don‚Äôt get the result you want\n- python variable naming conventions\n    - don‚Äôt use keywords\n        |     |     |     |     |     |     |     | \n        | --- | --- | --- | --- | --- | --- | --- |\n        | False | assert | del | for | in | or | while |\n        | None | break | elif | from | is | pass | with |\n        | True | class | else | global | lambda | raise | yield |\n        | and | continue | except | if | nonlocal | return |  |\n        | as | def | finally | import | not | try |  |\n    - don‚Äôt name your variable after a type, like `int` or `str`\n    - only use letters (upper + lower), numbers, underscores\n        - don‚Äôt start the variable name with a number\n    \n    | examples | nonexamples |\n    | --- | --- |\n    | CS220 | 220class |\n    | cs_220 | x! |\n    | _cs220 | pi3.14 |\n\n### downey ch2: variables, expressions and statements\n\n- python conventionally uses lowercase and underscores for variable names\n    - illegal names will cause syntax errors\n- python code can be saved into files called *scripts* which end with `.py`\n- `print()` needs to be used in script mode if you want to display outputs\n- PEMDAS is helpful for remembering the order of operation for expressions\n    - **P**arentheses, **E**xponents, **M**ultiplication and **D**ivision, **A**ddition and **S**ubtraction\n- can‚Äôt perform mathematical operations on strings but we *can* add strings together (called string concatenation)\n    ```python\n    first = 'throat'\n    second = 'warbler'\n    print(first + second)\n    \u003e throatwarbler\n    ```\n- strings can also be multiplied, ex: `'Spam'*3` is `'SpamSpamSpam'`\n- comments are lines that the computer will ignore ‚Äî used to make notes between lines of code for humans to read\n    ```python\n    # compute percentage of an hour\n    percentage = (minute * 100) / 60\n    ```\n    - everything on the line with the `#` symbol is ignored\n    - usually used to denote things that aren‚Äôt obvious to the reader ‚Äî meanings of variables, functions\n- syntax errors appear *before* the program is run; runtime errors appear *after* the program has run; semantic errors don‚Äôt appear at all\n\n---\n\n## using functions\n\n- functions are ‚Äúmini-programs‚Äù or small steps that can build a big program\n- refactoring is when the code is reorganized\n- **parameters** are variables that receive a function‚Äôs input\n- **arguments** are values that are sent to a function\n    - default arguments are values that are sent to the function *if* no custom value is provided\n- **return values** are outputs from the function\n![params-args](/images/cs220/params-and-args.png)\n- calling a function in python: `[fnc name]([arguments])` ex: `print(\"hello\")` where `print` is the function name, followed by parentheses, and `\"hello\"` is the argument\n\n### downey ch3: functions\n\n- **function** - a named sequence that performs a computation\n- python has *modules* which are prewritten code that you can use in your program by importing\n    - ex: functions from the math module can be used after importing it with `import math`, including `math.sin()`, `math.log10(), etc`\n- functions can be called using *dot notation* which is the format `[module name].[function name]`\n- variables are always on the left side of an assignment operator\n\n---\n\n## creating functions\n\n- math to python example\n    $f(x)=x^2$\n    `def f(x):\n        return x ** 2`\n    - both functions are called `f` and take a parameter, `x`, and return the value of `x` squared\n- indentation is important in python!\n    - following the colon after the first line of a function, all following lines are indented 4 spaces\n- filling parameters\n    - positional arguments ‚Äî arguments assigned by position\n        ```python\n        def foo(x, y = -1):\n            x = [] # this would be 99, because 99 is the first arg\n    \t    y = [] # this would be 100\n\n        foo(99, 100)\n        ```\n    - keyword arguments ‚Äî arguments assigned to variable names\n        ```python\n        def foo(x, y = -1):\n            x = [] # this would be 100 because we said x=100 below\n            y = [] # this would be 99\n        \n        foo(y=99, x=100)\n        ```\n    - default arguments ‚Äî inserted arguments if nothing is provided\n        ```python\n        def foo(x, y = -1):\n            x = [] # this would be 99 \n            y = [] # this would be -1 because we specified it above\n        \n        foo(99)\n        ```\n- `return` will provide code to the program that can be used later, while `print()` will output the code to a terminal\n\n### downey ch3 (cont.): functions\n\n- custom functions can be added by using the keyword `def`\n    - the **header** of the function is the first line, while the **body** **(indented 4 spaces) is the rest of the function\n- if the parentheses after the function name are empty, that means the function doesn‚Äôt take any arguments\n    ```python\n    def foo():\n        print(36)\n    \n    foo()\n    \u003e 36\n    ```\n- functions have to be created before they can be called ‚Üí function definitions are always at the top of a program\n    - execution begins at the top of the program and moves down\n- *fruitful functions* return values; *void functions* don‚Äôt return anything\n    - usually want to perform an action with the output of a fruitful function\n\n### reading: creating fruitful functions\n\n- to send a value to a variable instead of printing it to a screen, we can use the `return` keyword ‚Üí is called a fruitful function\n    - result is stored in a variable and can be used again\n    ```python\n    # using print\n    def get_name(first, last):\n        print(first + \" \" + last)\n    \n    name = get_name(\"Jane\", \"Doe\")\n    \u003e \"Jane Doe\"\n    \n    print(name)\n    \u003e None # nothing is assigned to 'name' so it has the None type\n    ```  \n    $\\phantom{-}$\n    ```python\n    # using return\n    def get_name(first, last):\n        return(first + \" \" + last)\n    \n    name = get_name(\"Jane\", \"Doe\") # nothing prints because there is no print statement\n    \n    print(name)\n    \u003e \"Jane Doe\" # the name is returned through the function\n    ```\n- once a `return` statement is reached, the function ends\n    ```python\n    # using print()\n    def countdown_print():\n        print(3)\n        print(2)\n        print(1)\n    \n    countdown_print()\n    \u003e 3\n    \u003e 2\n    \u003e 1\n    ```\n    $\\phantom{-}$\n    ```python\n    # using return\n    def countdown_return():\n        return 3\n        return 2\n        return 1\n    \n    countdown_return()\n    \u003e 3\n    ```\n- `__builtins__` is a special module that is already imported\n- `dir()` lists all functions that are part of a module\n- `.__doc__` returns the documentation of a function\n    ```python\n    import math\n\n    print(math.log.__doc__) # [module name].[function name].__doc__\n    \u003e log(x, [base=math.e])\n    \u003e Return the logarithm of x to the given value\n    ```\n\n---\n\n## function scope\n\n- variable names can be organized in *frames*\n- **frames** are created when a function is called ‚Äî parameters and variables exist in the frame (also called scope?)\n    ```python\n    def print_twice(s): # function frame\n        print(s)\n        print(s)\n    \n    def cat_twice(p1, p2): # different function frame\n        cat = p1 + p2\n        print_twice(cat)\n    \n    line1 = \"bing bong\" # lies in the global frame\n    line2 = \"bong bing\" # lies in the global frame\n    cat_twice(line1, line2)\n    ```\n    - the module can access two variables: `line1` and `line2`\n    - `cat_twice()` accesses three variables: `p1` (which is `line1` passed through the function), `p2` (which is `line2` passed through the function), and `cat`\n    - `print_twice()` only accesses one variable: `s` which is `cat` passed through\n- local variables\n    - functions don‚Äôt execute unless they‚Äôre called\n        ```python\n        def set_x():\n            x = 100\n        \n        print(x)\n        # doesn't print anything because set_x() wasn't called\n        ```\n    - variables created in a function die after the function returns\n        ```python\n        def set_x():\n            x = 100\n        \n        set_x()\n        print(x)\n        # doesn't print because x doesn't exist after the end of the function\n        ```\n    - variables are reset every time a function is called\n    - variables aren‚Äôt shared across functions\n        ```python\n        def display():\n            print(x)\n        \n        def main():\n            x = 100\n            display()\n        \n        main()\n        ```\n        - even though `x` is set to be `100` in the `main()` function, the `display()` function can‚Äôt see the `x` value and it doesn‚Äôt print anything\n- global variables can be used inside functions\n    - python assumes any variables assigned within functions are *local variables*\n        ```python\n        msg = \"hello\"\n        \n        def greeting():\n            msg = \"welcome!\" # local variable, only present within the function\n            print(\"greeting: \" + msg)\n        \n        print(\"before: \" + msg) \n        greeting()\n        print(\"after: \" + msg)\n        \n        \u003e before: hello\n        \u003e greeting: welcome!\n        \u003e after: hello\n        ```\n- use `global [var name]` to declare when to create a global variable\n    ```python\n    msg = \"hello\"\n    \n    def greeting():\n        global msgd\n        msg = \"welcome!\" # local variable, only present within the function\n        print(\"greeting: \" + msg)\n    \n    print(\"before: \" + msg) \n    greeting()\n    print(\"after: \" + msg)\n    \n    \u003e before: hello\n    \u003e greeting: welcome!\n    \u003e after: welcome!\n    ```\n- python arguments are ‚Äúpassed by value‚Äù meaning any change to an argument that happens inside a function does *not* apply to that variable outside of the function\n- the argument and parameter can have the same (or different) name\n\n### downey ch3 (cont.): functions\n\n- inside a function, arguments are assigned to variables called *parameters*\n- variables created inside functions exist only in that function\n- a **traceback** is a list of functions that details what file, line, and functions caused an error\n- usefulness of functions\n    - repetitive code can be named and grouped, which makes debugging easier\n    - reusuable\n- Linux started out as a program that would switch between printing `AAAA` and `BBBB`\n\n---\n\n## conditionals\n- statements are always executed in order, with three exceptions: functions, conditionals, and loops\n- indented lines = ‚Äúinside‚Äù functions\n- questions are often phrased as boolean expressions, while actions are written as statements\n- control flow diagrams are flowcharts for code ‚Äî visual representation of how the code should run\n    ![conditionals](/images/cs220/conditionals.png)\n- a boolean expression uses the `if` keyword and sometimes uses `else` if there are multiple solutions\n    ```python\n    if [boolean expression == True]:\n        # execute code\n    else: # implying that boolean expression == False\n        # execute different code\n    ```\n- *blocks* of code are defined by indentations (which come with colons)\n\n### downey ch4: case study: interface design\n\n- the `turtle` module in python allows you to create images with turtle graphics\n    - basically, it‚Äôs a little ‚Äúturtle‚Äù that you can control using commands (move forward, turn left) to draw stuff\n- `for` loops can be used to repeat pieces of code\n    ```python\n    for i in range(4):\n        print(i + \"hello!\")\n    \n    \u003e 0 hello!\n    \u003e 1 hello!\n    \u003e 2 hello!\n    \u003e 3 hello!\n    ```\n    - the `i` is a counter variable ‚Äî starting at 0, it will increase by 1 every loop\n    - `4` is the number of times the loop will repeat\n- **encapsulation** is when you wrap up code in a function\n    - this gives the code a name, which serves as documentation (noting what its purpose is)\n- **generalization** is adding parameters to a function to make it more ‚Äúcustomizable‚Äù, ex: creating a function that draws a square of *any* size instead of just 1 size\n- the **interface** of a function is a summary of how the function is used, including parameters, purpose, return values\n    - a good interface achieves its purpose without needing to provide unnecessary information\n- **refactoring** is the process of rearranging a program to improve interfaces ‚Äî the goal is to make the code more readable and still be useful\n- **docstrings** are strings at the top of a function that explains the interface (basically describes the purpose of the function)\n    - doc = documentation\n    - also called headers or javadoc comments in Java\n    - all docstrings are *triple-quoted*\n    ```python\n    def polyline(t, n, length, angle):\n        \"\"\"Draws n line segments with the given length and angle (in degrees) between them. t is a turtle.\"\"\"\n        for i in rage(n):\n            t.fd(length)\n            t.lt(angle)\n    ```\n- **preconditions** are things that are required to be true *before* the start of a function, ex: the `angle` parameter has to be a positive value\n- **postconditions** are conditions at the end of the function\n    - if the postconditions are wrong but the preconditions are satisfied, then the bug is within the function\n\n### downey ch5: conditionals ~~and recursion~~\n\n- the **floor division operator** (`//`) divides two numbers and returns the integer (rounds down), ex: `5 // 3 = 1`\n- the **modulus operator** (`%`) divides two numbers and returns the remainder, ex: `5 % 3 = 2`\n- a **boolean expression** will evaluate to either `True` or `False` and uses the `==` operator\n    - `!=` not equal to\n    - `\u003e` greater than\n    - `\u003c` less than\n    - `\u003e=` greater than or equal to\n    - `\u003c=` less than or equal to\n- **logical operators**: `and` `or` `not`\n- `if` statements are *conditional* statements, which check conditions\n    ```python\n    if x \u003e 0: \n        print(\"x is positive\")\n    ```\n    - if there is more than one possibility of the conditional statement, `else` clauses can be added\n        ```python\n        if x \u003e 0:\n            print(\"x is positive\")\n        else: \n            print(\"x is negative\")\n        ```\n    - if there are more than *two* possibilities, use `elif` to define other conditions\n        ```python\n        if x \u003e 0: \n            print(\"x is positive\")\n        elif x \u003c 0:\n            print(\"x is negative\")\n        else: \n            print(\"x is 0\")\n        ```\n- conditionals can also be nested inside each other ‚Äî the next example is a re-write of the previous one\n    ```python\n    if x \u003e 0:\n        print(\"x is positive\")\n    else:\n        if x \u003c 0:\n            print(\"x is negative\")\n        else:\n            print(\"x is 0\")\n    ```\n\n### downey ch6: fruitful functions\n\n- return values are usually assigned to variables or used in an expression\n    - if conditional statements are used, there can be multiple return statements ‚Äî it‚Äôs good practice to make sure the program can return a value no matter which path it takes\n- code that appears *after* a return statement is called **dead code** because it will never be executed\n- **incremental development** is the process of adding and debugging code in small chunks as to avoid long/complicated debugging sessions\n    - comments or tester pieces of code are called **scaffolding** which can be helpful for debugging, but aren‚Äôt part of the final product\n    - start with a working program and make small changes\n    - display intermediate values\n    - remove scaffolding to make code easier to read\n- one function can be called from within another\n- functions can return booleans\n    - common for the function name to be a yes/no question, like `is_even()`, `is_raining()`, or `is_divisible()`\n\n---\n\n## iteration\n\n- control flow diagram for a `while` loop\n    ![while-loop](images/cs220/while-loop.png)\n- basic code for a `while` loop\n    ```python\n    while [condition]:\n        # execute code\n    ```\n- to repeat a loop `n` times, either use `i = 1` and `i \u003c= n` OR `i = 0` and `i \u003c n` because python starts counting from 0 and not 1\n- `break` immediately exits a loop, just like how `return` will immediately exit a function\n- the keyword `continue` will stop the *current iteration* and checks the condition to begin the next iteration\n- loops can be nested\n\n### ch7: iteration\n\n- **reassignment** is when an existing variable is updated to have a new value\n    - equality in python (and other languages) isn‚Äôt achieved through the `=` operator, ex: saying `a = 3` and `a = b` does not mean `b = 3`\n- an **update** is a specific type of reassignment where the new value is dependent on the old value\n    - **increments** are when a variable is updated by adding 1, **decrements** are when a variable is updated by subtracting 1\n- a variable has to be initialized (it has to exist) before it can be updated\n- repetition can be called **iteration**\n- `while` loops will execute as long as the condition remains true after each iteration\n    ```python\n    while n \u003e 0: # while n is greater than 0, display and decrement n\n        print(n)\n        n = n - 1\n    print(\"Blastoff!\")\n    ```\n    - an **infinite loop** is a loop that repeats forever, and occurs when there is no way for the condition to evaluate as false\n- `break` statements can be used to exit loops in the middle rather than at the beginning or end\n- an **algorithm** is a mechanical process for solving problems\n\n### sweigart ch2: flow control\n\ntodo\n\n---\n\n## strings\n\n- python can compare strings just like it can compare numbers with three edge cases: upper vs. lowercase, digits, prefixes\n    - uppercase always comes before lowercase, ex: `\"Z\"` \u003c `\"a\"`\n    - numbers in string form aren‚Äôt actual numbers, they are still considered strings and digits are compared to each place, ex: `\"100\"` \u003c `\"15\"`\n    - prefixes always come first, ex: `\"bat\"` \u003c `\"batman\"`\n- the `isDigit()` function returns if all the characters within a string are digits\n- a **method** is a special function that‚Äôs called on a variable or value, such as `isDigit()` or `upper()`, while functions pass variables or values as parameters\n    ```python\n    msg = \"hello\"\n    \n    msg.isDigit() # method\n    msg.upper() # method\n    \n    len(msg) # function\n    ```\n- **sequences** are collections of ordered values, such as strings, lists, or tuples\n![array](images/cs220/string-array.png)\n- **indexing** a string is when you access a value of the string, while **slicing** is taking a chunk of a string\n    - each character in the string has its own *index* value which is the number to call to retrieve that character\n![indexing](images/cs220/string-indexing.png)\n- both `while` loops and `for` loops can be used to iterate through string\n    ```python\n    msg = \"hello\"\n    \n    # while loop\n    i = 0\n    while i \u003c len(msg):\n        letter = msg[i]\n        print(letter)\n        i += 1\n    \n    # for loop\n    for letter in msg:\n        print(letter)\n    ```\n- `for` loops can also have a *range* which is a way of telling the computer how many times the loop should be executed\n    ```python\n    for i in range(5): # will iterate 0 to 4\n        print(i * 3)\n    \n    \u003e 0\n    \u003e 3\n    \u003e 6\n    \u003e 9\n    \u003e 12\n    ```\n\n### downey ch8: strings\n\n- a string is a *sequence*\n- the **index** is a value that corresponds to a character within a sequence, ex: my sequence is `\"banana\"` and the value at index `1` is `\"a\"` (because python starts counting at 0)\n    - the index has to be an integer value\n- `len()` is a builtin function that returns the number of characters in a string\n- negative indices can be used to count backwards from a string, where the `-1` index returns the last character, `-2` index returns the second-to-last, etc\n- `for` loops can be used to traverse through strings, also called for-each loops\n    ```python\n    fruit = \"banana\"\n    \n    for letter in fruit: # the loop iterates from 0 to 5\n        print(letter)\n    \n    \u003e b # 0th index\n    \u003e a # 1st index\n    \u003e n # 2nd\n    \u003e a # 3\n    \u003e n # 4\n    \u003e a # 5\n    ```\n- string segments are called **slices** which can be obtained using the `[n:m]` operator where the operator includes the `n` letter but not the `m` value, ex: `fruit[1:4]` would return `\"ana\"`\n    - if the `n` is omitted, the slice starts at the beginning and ends at the `m` value, ex: `fruit[:4]` would return `\"bana\"`\n    - if the `m` is omitted, the slice starts at the `n` value and ends at the end of the string, ex `fruit[4:]` would return `\"na\"`\n    - a third argument can be used called *step size* which is the number of spaces between characters, ex: `fruit[0:5:2]` would return `\"bnn\"`\n        - `[start : end : step size]`\n- strings are **immutable** which means an existing string can‚Äôt be changed\n- a **counter** is a variable in a loop that starts at 0 and increments each time a condition is met ‚Äî sometimes the value of the counter is returned at the end of the loop\n- an **invocation** is when a *method* is called on an object, such as the `upper()` method, ex: `fruit.upper()` produces `\"BANANA\"`\n- the `find()` method can return the index where a substring (or character) starts, but it can also take an argument for which index in the string it starts looking at, ex: `fruit.find(\"na\")` produces `2`\n- the `in` operator for strings returns a boolean value if the substring is present in the string, ex: `\"a\" in \"banana\"` returns `True`\n- relational operators (`==`, `\u003c`, `\u003e`) work on strings and are used to put words in alphabetical order, but *all uppercase letters come before lowercase letters*\n\n### downey ch9: case study: word play\n\n- there is a built in function to read files ‚Äî `open( [filepath] )`\n- to read lines of the file, use `readline()`, which will read the next line of the file until it gets to the end of the file\n    - sometimes the lines will end with whitespace characters such as `\\r\\n` which we can get rid of by using the `strip()` function after the `readline()` function\n- the process of reading a file can be made easier by using a `for` loop\n- when testing programs, keep in mind **special cases** which are non-obvious cases that can produce errors, ex: what if a function is called on an empty string?\n\n\u003e Program testing can be used to show the presence of bugs, but never to show their absence! ‚ÄîEdsger W. Dijkstra\n\n---\n\n# state\n\n## lists\n\n- a string is a sequence of characters ‚Äî a list is a sequence of anything!\n    - we can index, slice, and put lists in `for` loops and also use the `len()` function, concatenate with the `+` operator, use the `in` operator to find elements, and multiply by integers\n```python\n# using len()\nmsg = \"321go\"\nlen(msg)\n\u003e 5\n\n# concatenation\nmsg = \"321go\"\nmsg + \"!!!\"\n\u003e \"321go!!!\"\n\n# using in\nmsg = \"321go\"\n\"g\" in msg\n\u003e True\n\n# multiply by int\nmsg = \"321go\"\nmsg * 3\n\u003e \"321go321go321go\"\n```\n$\\phantom{-}$\n```python\n# using len()\nitems = [99,11,77,55]\nlen(items)\n\u003e 4\n\n# concatenation\nitems = [99,11,77,55]\nitems + [1,2,3]\n\u003e [99,11,77,55,1,2,3]\n\n# using in\nitems = [99,11,77,55]\n11 in items\n\u003e True\n\n# multiply by int\nitems = [99,11,77,55]\nitems * 2\n[99,11,77,55,99,11,77,55]\n```\n![string-list](images/cs220/string-list-comparison.png)\n\n### downey ch10: lists\n\n- a **list** is a *sequence*\n    - elements of a list, called **items**, can be of any type (unlike strings, where they have to be characters) ‚Äî they can even be different types than other elements within the same list\n- to create a new list, use square brackets to enclose the elements, ex: `cheeses = [\"Cheddar\", \"Gouda\", \"Mozzarella\", \"Swiss\"]`\n- lists within lists are called *nested* lists\n- empty lists don‚Äôt contain elements and can be created using empty brackets, ex: `empty = []`\n- the bracket operator `[]` can be used to access elements of a list (just like how brackets are used to access characters in a string), ex: `cheeses[1] = \"Gouda\"`\n    - lists are **mutable** which means that elements in the list can be changed\n- the `in` operator can be used on lists to find elements\n- when iterating through lists, the `in` operator will NOT update the elements in the list ‚Äî to update the elements, you have to use `range()` and `len()`\n    ```python\n    cheeses = [\"Cheddar\", \"Gouda\", \"Mozzarella\", \"Swiss\"]\n    \n    for cheese in cheeses: # will NOT change the cheeses list\n        cheese = \"eaten\"\n    \n    for i in range(len(cheese)): # WILL change the cheeses list\n        cheese[i] = \"eaten\"\n    ```\n- the `+` operator will join lists while the `*` operator will repeat a list a given number of times\n- list slicing works the same way as strings ‚Äî using the `[start : end : step size]` operator, sections of lists can be isolated\n- since lists are mutable, a good programming practice is to make a copy of the list before modifying it\n- list methods\n    - `append()` adds a new item to the end of the list\n    - `extend()` takes a list as an argument and adds the entire list to the main list\n    - `sort()` arranges the list elements from low to high\n    - `pop()` removes and returns the final element in a list, or it can remove and return the item at a specified index\n        - the `del` keyword accomplishes the same thing but without a return value\n    - `remove()` removes the item with the specified *value*\n        ```python\n        cheeses = [\"Cheddar\", \"Gouda\", \"Mozzarella\", \"Swiss\"]\n        \n        # the two statements below achieve the same purpose\n        cheeses.pop(1) # used if you know the index\n        cheeses.remove(\"Gouda\") # used if you know the value\n        ```\n- special types of operators\n    - **map** alter every element in a sequence\n    - **reduce** simplifies a sequence of elements into a single value\n    - **filter** removes some elements and returns others, usually according to a user-given rule\n- the `list()` function breaks a string into a list of characters, ex: `list(‚Äùhello‚Äù)` returns `['h', 'e', 'l', 'l', 'o']`\n- the `split()` function breaks a string into a list of words\n    - it can take a **delimiter** as an argument which is a specified boundary to split words\n        ```python\n        delimiter = \"-\"\n        str = \"spam-spam-spam\"\n        \n        str.split(delimiter) # produces [\"spam\", \"spam\", \"spam\"]\n        ```\n- the `join()` function joins a list into a string\n- two lists can be *equivalent*, meaning they have the same elements, but not *identical*, because they are referring to two different objects\n- identical ‚Üí equivalent, but equivalent does not mean identical\n![equivalent](images/cs220/equivalent.png)\n- a variable assigned to an object is called a **reference**, and when an object has more than one reference, that means it is **aliased**\n    - if the aliased object is mutable, then any change will affect all aliases of the object\n- some operations (`append()` , `split()`, `[::]`) modify lists, while other operations (`+`, `*`) create new lists\n\n---\n\n## CSV tables\n\n- CSVs organize cells of data into rows and columns\n    - only holds strings and all text is plaintext\n- **delimiters** are characters that act as separators between objects ‚Äî for CSVs, the delimiter is a comma\n- when a CSV is opened in python, its result is a list of lists (or like a 2D array)\n\n### sweigart ch16: working with CSV files ~~and JSON data~~\n\n- CSV, comma-separated values, are simplified spreadsheets stored as plaintext ‚Äî supported by many types of programs and is very simple, exactly as advertised\n- each row in a CSV file represents a row in a spreadsheet, and each comma represents the next column\n- the `csv` module has a `reader` object which helps the user read the CSV file\n    ```python\n    import csv\n    exampleFile = open(\"example.csv\") # open the file\n    exampleReader = csv.reader(exampleFile) # \"reads\" the file and returns a reader object\n    exampleData = list(exampleReader) # converting data into list\n    \n    exampleData[0][0] # data at row 0, col 0\n    exampleData[0][1] # data at row 0, col 1\n    ```\n    - for larger CSV files, use a `for` loop and load one row at a time\n        ```python\n        for row in exampleReader: # iterating through reader object\n            str(row)\n            # execute code\n        ```\n\n---\n\n## dictionaries\n\n- a **data structure** is a collection of data values, their relationships, and the operations that can be applied to the data\n- **maps** associate values with labels and use labels to lookup values\n    - *lists* are maps which associate indices with values\n- dictionaries map labels (keys, not indices) to values ‚Äî keys must be immutable\n    ```python\n    nums_dict = {\"first\":900, \"second\":700, \"third\":800}\n    \n    nums_dict[\"third\"] # accessing 800\n    ```\n- reminder on parenthetical characters\n    - parentheses `()`: specifying order, calling functions\n    - brackets `[]`: creating lists, indexing, slicing, dictionary lookups\n    - braces `{}`: creating dictionaries, creating sets\n- use the `pop()` method to delete elements in the dictionary ‚Äî by default, `pop()` accepts keys\n- to add elements, assign keys to values using brackets like `d[20] = \"twenty\"`\n- create an empty dictionary `d = {}` or `d = dict()`\n- the `in` operator only checks if keys are present in the dictionary, it does not check for values\n- keys and values can be extracted and turned into lists using `list(d.keys())` or `list(d.values())`\n- use `get()` to return values, `pop()` to delete values in a dictionary and specify a default value if the key doesn‚Äôt exist\n- **bucketing/binning**: dictionary of lists\n![bucketing](images/cs220/bucketing.png)\n- **table representation**: list of dictionaries\n- **probability tables/Markov chains**: dictionary of dictionaries\n![probability-dict](images/cs220/probability-dict.png)\n\n### downey ch11: dictionaries\n\n- dictionaries have **keys** and **values** which make up **items** ‚Äî each key is mapped to a value\n- create a new dictionary using the `dict()` function or two curly brackets `{}`\n    - add elements to a dictionary by using square brackets and assigning a value, ex: `nums[\"1\"] = \"one\"` where `nums` is the dictionary, `\"1\"` is the key, and `\"one\"` is the value\n- dictionaries are not ordered ‚Äî the only thing that matters is the key-value pairs stay the same\n- the `values()` method returns a collection of all the values\n- the `in` operator, `len()` function, and `sorted()` function all work on dictionaries\n- the `get()` method returns the corresponding value associated with a key ‚Äî if there is no value then it returns a default value\n- a list can be a value in a dictionary, in other words, a list can be a value that is assigned to a key:value pair\n    - a list cannot be a key because the keys need to be hashable\n- a **singleton** is a list that contains a single element\n- a **hash** is a special function that takes values of any kind and returns and integer\n    - dictionaries use the integers (called hash values) to store key:value pairs\n    - hashes only work if the object is immutable (and lists aren‚Äôt immutable)\n- a **memo** is a dictionary that can be used to keep track of values that are already known\n    - when calculating the Fibonacci sequence, a memo can be used to store values that were already calculated\n- variables created outside functions are called **global variables** because they are located in the `__main__` frame\n- **flags**, boolean values for conditions, are usually global variables\n    - have to be declared within functions before they can be changed, ex: `global is_called` before using `is_called = !is_called`\n\n---\n\n## JSON\n\n- CSVs are good at storing list of lists, JSONs are good at storing dict of dicts\n\n### sweigart ch16: working with ~~CSV files and~~ JSON data\n\n- JSON, JavaScript Object Notation, stores information as JavaScript source code in plaintext files\n- application programming interface (API) is a way to bridge programs with their applications\n    - lets you scrape raw data from the website\n- the `json` module handles all the stuff between JSON data and python values using `json.loads()` and `json.dumps()` functions\n    - data can be read with the `loads()` function which will return the data as a dictionary\n    - data can be written with the `dumps()` function which can only take dictionary, list, int, float, string, Boolean, or `None` data types and will translate it into JSON data\n\n---\n\n## objects\n\n- using parentheses instead of brackets will create a tuple instead of a list\n    - like a list, `for` loops, indexing, slicing can be done\n- the `namedtuple` object can be imported and it will allow new types to be created\n    ```python\n    from collections import namedtuple\n    \n    Person = namedtuple(\"Person\", [\"fname\", \"lname\", \"age\"])\n    people = [\n        Person(\"Alice\", \"Anderson\", 30)\n        Person(\"Bob\", \"Baker\", 31)\n    ]\n    p = people[0]\n    print(\"Hello \" + p.fname + \" \" + p.lname)\n    \n    \u003e Hello Alice Anderson\n    ```\n- the mutable equivalent of a `namedtuple` is called a `recordclass`, ie: variables can be changed after they have been assigned\n- python uses separate references and objects because: 1) performance; 2) centralized updates\n- the `is` operator will return `True` when two references point to the same object, while the `==` operator only checks if the two objects are equivalent\n\n### downey ch10: lists\n\n- the `is` operator can tell you if two objects are equivalent and identical\n- identical implies equivalent, but equivalent does not imply identical\n\n### downey ch12: tuples\n\n- a tuple (too-ple) is an immutable list usually enclosed in parentheses ‚Äî create an empty one using `tuple()`\n    - can also refer to a group of objects in general\n- the bracket operator (for indexing) and slice operator `[::]` work on tuples\n- for relational operators (`\u003c`, `\u003e`, `=`) work by comparing each element of the tuple until there is a difference, and subsequent elements are not considered\n    - `(0, 1, 2) \u003c (0, 3, 4)`\n    - `(0, 1, 2000000) \u003c (0, 3, 4)`\n- tuples can be assigned in a special way\n    ```python\n    a, b = b, a\n    # tuple of variables on the left\n    # tuple of expressions on the right\n    ```\n    - the number of variables on the left side has to be equal to the number of expressions on the right side\n        ```python\n        addr = \"monty@python.org\"\n        uname, domain = addr.split(\"@\")\n        ```\n- a parameter that begins with `*` will **gather** all arguments into a tuple\n    ```python\n    def printall(*args):\n        print(args)\n    \n    printall(1, 2.0, \"3\") # combines all arguments into tuple\n    ```\n- an argument that uses the `*` operator on a tuple will break the tuple (**scatter**) into multiple arguments (so the opposite of a *gather*)\n    ```python\n    t = (7, 3)\n    divmod(*t) # breaks t into 2 arguments\n    ```\n- the `zip()` function takes multiple sequences and returns a list of tuples where each tuple has an element from each sequence\n    - the zip object is an **iterator** which means that it‚Äôs an object that iterates (moves through) a sequence ‚Äî usually has a `.next()` and no indices\n    ```python\n    s = \"abc\"\n    t = [0, 1, 2]\n    zip(s,t) # creates a zip object\n    \n    for pair in zip(s,t):\n        print(pair)\n    \n    \u003e (\"a\", 0)\n    \u003e (\"b\", 1)\n    \u003e (\"c\", 2)\n    ```\n    - if the sequences are different lengths, the zip object ends when the first sequence ends\n    - this is very useful for traversing through multiple sequences at the same time\n- the `enumerate()` function creates an enumerate object, or a sequence of pairs matching an index to an element in the argument\n    ```python\n    for index, element in enumerate(\"abc\"):\n        print(index, element)\n    \n    \u003e 0 a\n    \u003e 1 b\n    \u003e 2 c\n    ```\n- dictionaries have a method called `items()` that returns a sequence of tuples of key:value pairs\n- a list of tuples can be initialized into a new dictionary using `dict()`\n- tuples are commonly used as keys in dictionaries because lists can‚Äôt be used as dictionaries (tuples are immutable, lists are not)\n\n---\n\n## copying\n\n- slicing creates a new object\n- three levels of copying\n    - reference copy (0 levels): fastest but most dangerous, only creates a pointer to the object ‚Äî any changes to either object will change both\n    - shallow copy (1 level): used to copy an object (ie, a list) so the original doesn‚Äôt get corrupted, but it only makes a new object (a new list) that refers to the same original objects\n        - helpful for reorganizing object positions like sorting a list or dictionary, but not helpful if you want to change values\n    ![shallow-copy](images/cs220/shallow-copy.png)\n    - deep copy (all levels): slowest but the safest, copies everything including sub-lists and sub-dictionaries ‚Äî any changes made in the copy is not reflected in the original\n\n### sweigart ch4: lists\n\n- when assigning lists to variables, a *reference* to the list is what‚Äôs stored, not the actual list itself\n    - so if two variables point to the same list, then any change made on one variable will reflect on the other\n- python uses **references** when storing values of mutable types, like lists or dictionaries; it will store actual values for immutable types like strings, ints, or tuples\n    - even though lists and dictionaries are passed by reference through functions, they will still be altered directly\n- the `copy` module provides a `copy()` and `deepcopy()` function that makes duplicate copies of dictionaries or lists (and not just references)\n    - if the copy contains lists, use `deepcopy()` because it will copy inner lists\n\n---\n\n## recursive functions\n\n- a tree is an example of recursion where there are **recursive** cases (branches) and **base cases** (leaves)\n- a **recursive** function calls itself, directly or indirectly\n- both iteration and recursion achieve the same purpose but often one is more efficient or easier to implement than the other\n- an example using factorials\n    ```python\n    def fact(n):\n        if n == 1:\n    \t    return 1\n        p = fact(n-1)\n        return n*p\n    ```\n- variables exist in a frame, which are stored in stacks ‚Äî only the topmost frame is active at a time\n\n### downey ch5: ~~conditions and~~ recursion\n\n- a function that calls itself is a **recursive** function and executing that function is called **recursion**\n- a **base case** is the last call of the recursive function and it does not make another call\n    - if a recursion never reaches a base case, then it‚Äôs an **infinite recursion** and the program will never end\n\n### downey ch6: fruitful functions\n\n- return values are passed back up the recursion stack\n- an example with the Fibonacci sequence\n    ```python\n    def fibonacci(n):\n        if n == 0:\n    \t    return 0\n        if n == 1:\n    \t    return 1\n        else:\n            return fibonacci(n-1) + fibonacci(n-2) # calls itself\n    ```\n- sometimes the the function can miss the base case and keep recursing, so it‚Äôs good practice to make sure the input to the function is legal\n    - a **guardian** is a chunk of code that protects the code from executing on the wrong arguments\n\n---\n\n## function references\n\n- functions are objects, so they behave like objects\n    - can be referenced by variables, lists, or dictionaries; pass function references to other functions\n- if two different variables are assigned to a function, then both variables can call the function\n    ```python\n    def f():\n        return \"hi\"\n    \n    g = f\n    \n    f() # returns \"hi\"\n    g() # also returns \"hi\"\n    ```\n- function invocations have parentheses, function references *do not*\n- method references can be passed through parameters if the module name is used in the function invocation like, ex: `str.upper(val)` does the same thing as `val.upper()` but using `f = str.upper`, we can call `f(val)`\n- the `sorted()` function has a `key` parameter that allows you to choose what to sort the items by, and the `key` can be a function reference\n    - `attrgetter` is for namedtuples, `itemgetter` is for lists(?)\n\n---\n\n## generator functions\n\n- for recursive functions, make sure the arguments are changing and will at some point hit the base case\n- an eager function will finish execution before returning the end value, whereas a lazy function returns a value at each step and needs to be prompted to return the next value\n- a **generator** can stop and return a value and then execute more code after\n    - use the `yield` keyword\n    ```python\n    def f():\n        yield 1\n        yield 2\n        yield 3\n    \n    for val in f():\n        print(val) # printed once every loop\n    \n    \u003e 1 # goes back to executed yield 2\n    \u003e 2\n    \u003e 3\n    ```\n- multiple instances of the same generator can be executing at the same time\n- the `next()` function is built for generator objects and it will iterate through a generators\n    - by default, generator objects (from yield statements in functions) will create generator instances which can be used by `next()`... I think‚Ä¶\n- an **iterable** is something that can be iterated over, such as sequences like list, tuple, ranges, or `dict.keys()` or `dict.values()`\n    - an **iterator** object is an *iterable* object and can be created for *any iterable object* ‚Äî it‚Äôs a special object with the `next()` function\n- is `iter(x)` works, then `x` is iterable; if `next(x)` works, then `x` is an iterator\n\n---\n\n## error handling\n\n- turn semantic errors into runtime errors\n- a string can be formatted using brackets and `.format()`\n    - `\"area={:.2f}\".format(2.29834)` will print to `2.29` (CHECK)\n- anything that can be used in a boolean statement can also be used in an **assertion** which will throw an error and end the program if it‚Äôs false\n- the `try` and `except` blocks let you run code even after it crashes ‚Äî any errors thrown in the `try` block will prompt the `except` block to run\n    - when an error occurs in a `try` block, the program tries to find the closest `except` block to execute ‚Äî python will exit functions or loops until it can raise the exception\n- specific exceptions can be specified using `Exception` objects\n    ```python\n    try:\n        print(1/0) # buggy code\n    except Exception as e:\n        print(\"An exception was raised: \" + str(e) + \" \" + type(e))\n    ```\n    - it‚Äôs good practice to get very specific about exceptions so the user knows what went wrong\n- to crash the program manually, raise an exception with `raise [Exception](\"error message\")` ‚Äî the program will search for an `except` clause\n\n### sweigart ch10: debugging\n\n- python raises **exceptions** when the code is wrong but exceptions can also be manually raised using `raise Exception(\"error message\")`\n- **tracebacks** can tell you which line the error appeared on\n- there is a `traceback` module that allows you to manually deal with bugs and output them to log files, which means the program will keep running even if exceptions are thrown in the background\n- an **assertion** is a sanity check to make sure the code is doing what it‚Äôs supposed to do, ex: `assert [condition], \"[error message]\"`\n    - if an assertion fails, the error message is displayed and an `AssertionError` is thrown\n\n---\n\n# data science\n## files and directories\n\n- `f = open(\"path\")` will open a file and allow you to read from and write to `f`\n    - always close your files after using them!\n- to read a file, either use `read()` to return the *entire file content* into a string, `next()` to get one line of the file at a time, or `list()` to turn the file contents into a list\n- the `write()` function allows you to write to a file\n- the `os.path.join()` function will join parts of a path together ‚Äî this is useful because different OS use different forward and backward slashes and this function allows your code to run on multiple platforms\n- **encoding** is taking data and making it readable to the computer, while **decoding** is taking computer-language and making it readable to a human\n- the best way to parse data from large files is to use a generator to turn the data into a stream\n- using `with open(\"path\") as f:` will accomplish the same thing as just using `open()` but it‚Äôs faster (because whole data isn‚Äôt moved into memory) and the closing clause isn‚Äôt required\n- `json.dump(\"file\", [file object])` is the equivalent of `json.dumps(\"file\")` and `f.write()`\n- `data = json.load(f)` is the equivalent of `f.read()` and `json.loads()`\n- `os.path.basename(path)` names the file at the end of the path\n\n### downey ch14: files\n\n- **persistent** programs run all the time and permanently store some of their data ‚Äî this includes OS and web servers\n- to write to a file, it has to be opened in ‚Äúwrite mode‚Äù using `open(\"file path\", \"w\")`\n- the **format operator** is `%` and is preceded by a **format sequence**, ex `\"%d\"` is the sequence to format an argument as a decimal integer within the string\n    ```python\n    camels = 42\n    print(\"I have spotted %d camels.\" % camels)\n    \u003e \"I have spotted 42 camels.\"\n    ```\n    - there is also `\"%g\"` for floating-point numbers and `‚Äú%s‚Äù` for strings\n    - the number of format sequences must match the number of arguments that come after the format operator\n- **directories** are also called folders\n- a **relative path** specifies where a file is located with respect to the ‚Äúcurrent working directory‚Äù, while an **absolute path** specifies how to get to a file from the root of the entire system\n- the `os` module (stands for ‚Äúoperating system‚Äù) includes functions for working with files and directories ‚Äî `os.path.abspath()` to find absolute path, `os.path.exists()` to check if a file or directory exists, etc‚Ä¶\n- a **database** is like a permanent dictionary that organizes data ‚Äî python offers the `dbm` module to work with databases\n    - each item in the database has an associated **bytes object**\n    - the `pickle` module translates any object into a string to be stored in a database\n- any program that can be launched from the shell, can also be launched from within python using a **pipe object**\n- any file with python code in it can be imported as a module\n\n---\n\n## pandas\n\n- tabular data is data that is organized with tables and columns ‚Äî using the `pandas` module to order this data is much easier than using lists\n    - Pandas tables are built using `Series` which is a special data structure\n- pandas terminology\n    - *integer position* is a label like 0, 1, 2, that is equivalent to a list‚Äôs index\n    - *index* is equivalent to a dict‚Äôs key\n- lookup values using indices (keys) `.loc[\"key\"]` or lookup by integer positions (index) `.iloc[\"index\"]`'\n    - negative indexing isn‚Äôt supported by Series\n    - new slices are not indexed from 0\n- operations on Series work like vector math ‚Äî the operation is applied to every element\n    ```python\n    nums = Series([100, 200, 300])\n    nums + 1 # adds one to every element\n    \n    Series([1,2,3]) * 3 # multiples all elements by three\n    \n    Series([10,20]) + Series([3,4]) # results in Series([13, 24])\n    ```\n    - comparisons can also be done (`%`, `\u003e`, `==`)\n- boolean indexing is where you take every value in a Series that matches to `True` in a boolean Series, also called ‚Äúfancy indexing‚Äù\n    ```python\n    letters = Series([\"A\", \"B\", \"C\", \"D\"])\n    bool_series = Series([True, True, False, False)]\n    \n    letters[bool_series]\n    \u003e 0    A\n    \u003e 1    B\n    \n    letters[Series([False, True, False, True])\n    \u003e 1    B\n    \u003e 3    D\n    ```\n- example combining operations and fancy indexing\n    ```python\n    S = Series([1,9,2,3,8])\n    B = S \u003e 5 # Series that evaluates to True at any index where S\u003e5\n    \n    S[B] # filtering out values in S\n    \u003e 1    9\n    \u003e 4    8\n    ```\n- use and `\u0026`, or `|`, not `~` when chaining multiple conditionals for fancy indexing\n- a `DataFrame` is a table of aligned Series\n- calling a comparison function will compare Series even if the indices are mismatched (keys/indices are arranged wrong) ‚Äî `gt()`, `eq()`, `ge()`, `le()`...\n- a DataFrame is made up of a dictionary of Series but it could be a dict of lists, a list of lists, dict of dicts, list of dicts\n    - the indices can be specified when creating a DataFrame, ex: `DataFrame({data}, index=[\"row titles\"])`\n- to access a single cell in a DataFrame, use `loc[row,col]`\n- to read a CSV file, use `pd.read(\"file path\")` which will automatically add it as a DataFrame\n\n---\n\n## web\n\n- manual downloading is tedious; datasets are difficult to download in complete\n- every machine has an IP address and requests are sent between IPs but nicknames (domains) are easier to remember and are often used in place of IPs\n    - ports are specific locations on the ends of IP addresses\n    - domain: which computer; port number: which program; file name: which data\n- a URL puts together all elements of a request to a machine, ex: `https://en.wikipedia.org:443/wiki/URL`\n- `GET` specifies that we want to get data from the remote server; `POST` means we are uploading data to the server\n- status codes\n    - 200 is good\n    - 404 is the file isn‚Äôt available (file not found)\n    - 500 is a server error\n- all data parsed from webpage is formatted in a single string (I think)\n    - the shortcut to turn a .json file into a dict is `[requests.get('url')].json`\n- hypertext is text that is clickable links\n- browser sends a URL (domain, port, file) HTTP request\n- HTML stuff\n    - tags `\u003cb\u003e`, `i`, `u`..., allow you to group pieces of content together and apply special effects\n    - hyperlinks: `\u003ca href=\"[link]\"\u003e\u003c/a\u003e`\n    - images: `\u003cimg src=\"source\"\u003e`\n    - tables: `\u003ctable\u003e`, rows `\u003ctr\u003e`, cell `\u003ctd\u003e`\n- python can convert to html by outputting (`open(html_path, ‚Äúw‚Äù)`) to a .html file\n    - each tag has to be written to the file‚Ä¶ it‚Äôs not like .csi files in java where the code is mixed\n- BeautifulSoup allows for searching within HTML files\n- the browser takes HTML and generates a DOM (Document Object Model) Tree\n![dom-tree](/images/cs220/dom-tree.png)\n- BeautifulSoup creates a new DOM object when using `BeautifulSoup([data], [parser])`\n    - the `find_all()` function will return a list of all elements with that tag ‚Äî `find()` returns the first instance\n    - once the elements are found, use the `get_text()` function which will parse the text within those elements\n- if there are nested tags within an element, use the `.children` attribute which will return a list of the children tags of the parent element\n- most websites have a `robots.txt` file which will tell you what‚Äôs allowed and disallowed when ‚Äúcrawling‚Äù (pulling data from) in their site\n\n### sweigart ch11: web scraping\n\n- **web scraping** is downloading and processing content from the web\n- the `requests` module lets you download files from the web (has to be install from cmd)\n    - `requests.get()` returns a Response object\n        - `raise_for_status()` checks for if the request went through ‚Äî will produce errors like 404 not found, etc\n- save and write the web page to a file\n    ```python\n    res = requests.get('https://automatetheboringstuff.com/files/rj.txt')\n    res.raise_for_status()\n    playFile = open('RomeoAndJuliet.txt', 'wb')\n    for chunk in res.iter_content(100000): # chunks in bytes\n    \t\tplayFile.write(chunk)\n    \n    playFile.close()\n    ```\n- the Beautiful Soup (bs4) module parses HTML files in the drive\n    - why is web parsing and pandas more tedious to read than the entire two units of this course combined? this is an absolute slog and idk what‚Äôs going on even\n    - `exampleSoup = bs4.BeautifulSoup(open(\"example file\"))`\n    - the `select()` method will parse specific CSS syntax, ex: `soup.select(\"div\")` will find all elements named `\u003cdiv\u003e`\n- the `selenium` module can directly control the browser by clicking links and filling in login information\n- the shortcut of performing an action to every element in a list is `new_list = [action for x in old_list]` ‚Äî called list comprehension\n- defaultdict is a dict object that gives a default value to a key if it doesn‚Äôt exist in the dict yet\n\n---\n\n## databases\n\n- SQL databases are collections of named tables where all columns have an enforced type ‚Äî CSV files are just one table of strings\n    - can keep multiple copies of the same data stored in different ways to make retrieval efficient\n- SQL (structured query language) servers include Oracle, MySQL, SQLite\n- `sqlite3.connect(filepath)` is basically opening the file and will return a Connection object\n    - use pandas to read everything in the db `pd.read_sql(\"SELECT * FROM sqlite_master\", [connection obj])` and save it into a DataFrame to parse\n- SQL has different type names: `INTEGER`, `REAL`(float), `TEXT`(str)\n- `CREATE TABLE` signifies new table and will be followed by the table name\n- to get data and narrow down to to specific cells, start with `SELECT [ ] FROM [table name];` and follow in the order below\n    - `SELECT` which columns\n    - `FROM` which table\n    - `WHERE` which rows; filtering in the original table\n    - `GROUP BY` groups into categories (buckets)\n    - `HAVING` which rows, filters from the sorted groups above\n    - `ORDER BY` sorts the data ‚Äî `ASC` ascending, `DESC` descending\n    - `LIMIT` how many rows\n- the `AS` keyword creates a new column and can be used later\n- aggregate queries\n    - `COUNT()` counts the number of items in a col\n        - use `DISTINCT` to remove duplicates\n    - `SUM()` adds entire col together\n    - `AVG()` averages a col\n![sql-sequence](/images/cs220/sql-sequence.png)\n\n---\n\n## plotting\n\n- pandas Series and DataFrames integrates with matplotlib\n    - `[Series].plot.pie(figsize=(width, height), color=\"\")` makes a pie chart out of a Series\n    - `[s,df].plot.bar()` makes a bar plot\n        - the Series object can be directly altered before it‚Äôs plotted, ex: `([Series] / 100).plot.bar()` will divide all elements in the Series by 100 and plot accordingly\n        - the DataFrame bar plot takes a parameter `stacked=` which will make a stacked bar plot\n    - `[DataFrame].plot.scatter(x=\"\", y=\"\")` makes a scatter plot out of a DataFrame\n        - `s=` size of the points\n        - `c=` color of the points\n            - `vmin` takes a floating-point value that restricts the b/w of the plot points‚Ä¶\n        - `marker=` shape of the points `\"o\"` `\"+\"` `\"^\"` `\"v\"`\n        - set the limits of x and y axes using `xlim=` and `ylim=`\n    - `[s,df].plot.line()` line plot for Series or DataFrame\n        - the index is the x-axis unless otherwise specified\n            - for Series, use `s.sort_index()`\n- change default plot settings (like font size) by calling `matplotlib.rcParams[\"setting\"]`\n- once a plot is made, it returns an AxesSubplot object which can be tweaked\n    - `plot.set_title(\"title\")`\n    - `plot.set_ylabel(\"label\")`\n    - `plot.set_xticklabels(list([Series].index), rotation=)` sets the orientation of the x-axis labels\n    - `plot.splines[‚Äùright‚Äù, ‚Äútop‚Äù, ‚Äúbottom‚Äù, ‚Äúleft‚Äù].set_visible[True, False]`\n        - splines are the edges of the graph\n- it‚Äôs good practice to make a function that makes your plots look the same\n    - the main plot can be divided into subplots which you can specify settings for\n    - `fig, ax = plt.subplots()` and then customize the axis\n- set the index of a DataFrame using `[DataFrame].set_index()` to have custom tick labels\n    - tick positions also need to be set with `[df.plot.line()].set_xticks([list])`\n- define a custom header of a DataFrame using the `name=` parameter\n- to make a scatter plot for multiple classes, you have to loop over each class while plotting on the same `AxesSubplot`\n    - define a list of colors to change colors as you loop through classes `colors = []`\n    - add a legend using `label=` and the title of the class\n- use `cumprod()` to find the cumulative product\n- with large amounts of data, only present the important percentiles (using `.quantile(percentile=, axis=[column])`)and not the whole set of data\n- drop NaN values using `dropna()`\n- verify that data points aren‚Äôt being cut off in a plot using `assert` statements to compare `xlim` and `ylim` with the max values of x and y axes\n    - ex: `assert [df[axis]].max() \u003c= [ax].get_xlim()[?]` 0 or 1‚Ä¶?\n- log base 10 refocuses into how long the number is (how many 0s) instead of digits ‚Äî logarithmic scale is used so small values aren‚Äôt ‚Äúbrushed aside‚Äù when plotting\n- `plot.subplots()` can take a parameter `ncols=` and `nrows=` which will create multiple AxesSubplot objects\n    - to ensure the same y-axis across multiple graphs, use the parameter `sharey=True`\n\n---\n\n## randomness\n\n- `random.choice([list])` returns a random value from the list (using the `random` module) ‚Äî sampling with replacement\n    - `random.choices([list], size=)` returns `size` random values ‚Äî `size` can also be a tuple to generate multidimensional arrows (row, col)\n    - takes a parameter `p=` where the probability can be predetermined\n- how do we know if something is really random? look at a large sample size\n- seeds are predetermined random sequences ‚Ä¶ like Minecraft\n    - it‚Äôs easier to debug errors that depend on randomness if the randomness can be controlled through seeds\n- large difference in a small data set, or a small difference in a large data set means it might not be random","lastmodified":"2023-08-24T05:02:02.331071971Z","tags":[]},"/notes/cs544":{"title":"CS 544","content":"\n# resources \u0026 deployment\n\n## intro\n- Big 3 categories of software:\n    1. Analysis code -- running Python code once on some data to get results\n    2. Application -- continuously running the code, like a website\n    3. Systems -- how to manage resources such as storage space\n- Systems resources:\n    - compute -\u003e CPU, GPU\n        - CPUs can each have multiple cores, which can be independently executing \"core code\" (machine code)\n        - More cores means that more tasks can be run simultaneously\n        - High level code -\u003e compiled to bytecode -\u003e ran by a VM -\u003e VM is running on a core\n        - GPU has many cores that are coordinated and slow because they have to run together\n        - Cost measurement: FLOPS (floating-point operations per second)\n    - mem -\u003e RAM\n        - RAM stores bits\n        - Small, volatile (lost upon reboot) and fast\n    - storage -\u003e HDD, SSD\n        - Data read/written in blocks of many bytes/blocks\n        - Large, nonvolatile, slow\n        - How fast can be read/write data? This is measured in throughput\n    - network -\u003e NIC (network interface card)\n        - Data access speed can be based on network topology -- which servers are physically closest\n- How do we efficiently utilize the four above resources?\n    1. Scale UP: get more mem/compute power\n    2. Scale OUT: cluster machines (expensive)\n\n---\n\n## deployment \n### (linux)\n- `which` where something is installed / located\n- shebang line tells you what interpreter should run the code\n- `|` pipe character chains output from one program to the input of another program\n    - programs don't wait for the previous one to conclude, they use streams\n- `\u003e` redirects input/output\n    `\u0026\u003e out.txt` sends stdout and stderr to `out.txt`\n    `2\u003e` just sends stderr somewhere\n- `\u0026` sends program to the background to run asynchronously\n- `wc` word count produces `lines words chars`\n- `grep` search \n- `find` finds all files wrt current dir\n- `\u003e\u003e` append to a file instead of overwriting it with `\u003e`\n- `ps` lists running processes\n- `kill [id]` kills a process by id\n- `pkill [name]` kills a process by name\n- `htop` memory usage\n- `df -h` storage usage\n- `lsof` list open files, shows every file that every program has open\n    - `-i tcp` shows which programs are running using tcp\n\n\n### (docker)\n- **Virtualization** is the idea that processes are given private resources such as memory or hardware\n    - One example is virtual address spaces which are chunks of memory in a larger block of memory, another example is a VM\n- Docker is a way of creating lightweight virtual operating systems, which are called *containers*\n- The purpose of containers / VMs are to create sandboxes which can run code in an isolated environment\n    - For example, running malicious code in a sandbox will not affect anything outside of the sandbox\n- **Docker image**: a snapshot of a container\n    - Containers can be created on your VM from an image\n    - Dockerfiles set up environments\n        - Dockerfiles will cache intermediate progress, so it's good practice to put stuff that's stable at the top, and stuff that's constantly changing near the bottom of the Dockerfile\n- Use `docker run -it IMAGE_NAME bash` to get an interactive terminal to run inside a docker container\n- Use `docker run IMAGE_NAME sh -c \"COMMAND\"` to run a command inside an image without going into the image\n- Useful troubleshooting commands: `logs`, `exec`, `stats`, `kill`\n- Each container has its own set of ports\n    - If we have two containers, `lo` and `ens0`, then there is a port 80 for each of them\n    - We can manually map ports from the laptop to a virtual machine, which would allow the user to specify which port 80 they want to use\n- Docker orchestration is for deploying many containers (cluster) that are cooperating, ie: Kubernetes or √üDocker compose\n    - Create a file named `docker-compose.yml` to get started\n```yaml {title=\"example docker compose file\", linenos=false}\nservices:\n    jupyter:\n        image: myimg\n        deploy:\n            replicas: 3\n    # TODO: other processes\n```\n\n---\n\n## memory resources \n### (caching)\n- There is latency when loading data from RAM into CPU, the solution to this is the cache \"hot\" data\n- Caching is a resource tradeoff -- if I cache a file, I avoid rereading from storage, but I'm using up memory\n- What do we cache? Data/webpages that we need to access repeatedly\n- When do we cache? The first time we read something, it is added to the cache\n- When do we remove (evict) from the cache? Depends, there are several policies\n    - Why do we evict? Limited cache space\n    - Random: remove cache entry at random\n    - FIFO (first in, first out): remove whatever has been in the cache the longest\n    - LRU (least recently used): remove the cache item that was accessed the longest ago\n- FIFO and LRU are bad when you need to keep scanning the same data repeatedly because you can have a situation where you evict the values that you need next\n    - Cache size = 4, Data = [1,2,3,4,5,1,2,3,4,5], then the hit rate is 0%\n- Avg latency = (hit% * hit latency) + (miss% + miss latency)\n\n---\n\n## compute resources \n### (pytorch numbers)\n- Specify exactly how many bits are used for the numbers we're working with (uint8, float32, etc)\n    - Tradeoffs: precision, range, memory\n- Numbers in PyTorch are called \"tensors\"\n- Ints will overflow/underflow, floats will return as inf or nan\n- Sigmoid function maps to 0 or 1\n- A PyTorch model (`torch.nn.Linear`) is like a function, it can be called on tensor data\n- Callable objects in Python\n    - Use the `__call__` function to define what happens if that object is used as a function\n```python\nclass Mult:\n    def __init__(self, factor):\n        self.factor = factor\n\n    def __call__(self, number):\n        return number * self.factor\n\ndouble = Mult(2)\ndouble(10) # prints 20\n\ntriple = Mult(3)\ntriple(5) # prints 15\n```\n\n\n### (pytorch optimization)\n- Gradient is the slope at a particular location (in a function)\n- Stochastic gradient descent: optimization using slopes\n```python\nx = torch.tensor(0.0, requires_grad=True) # init at x = 0.0\noptimizer = torch.optim.SGD([x], lr=0.01) # optimize x values with learning rate 0.01\n\nfor epoch in range(5):\n    y = f(x) # apply f to get new y value\n    y.backward() # figuring out gradient wrt y -\u003e y/x\n\n    optimizer.step() # makes a change to variables based on gradient and learning rate\n    optimizer.zero_grad() # resets gradient to 0 because `.step()` adds to the current gradient value\n```\n- Learning rate is hard to optimize -- too big and you will miss the target, too small and it will take too long to solve\n\n\n### (pytorch ml)\n- Random split\n    - Randomly split into train, validation, and test data sets\n    - Why might a model score worse on test data than on validation data? Because we chose the model that fits the best to the validation set.\n- Deep learning uses models that are deeply nested functions\n$$y = \\text{model}(x) = L_N(R(L_{N-1}(R(\\cdots(L_1(x))))))$$\n- Each $L_k(x)$ stands for a model represented by $L_k(x) = xW+b$ while $R$ stands for a function like sigmoid or ReLU\n- PyTorch helps us track computations through DAGs\n![ML DAG](/images/image-1.png)\n- Loss (Mean Squared Error) depends on a lot of things, so loss is what we try to optimize\n- Stochastic gradient descent is doing gradient descent in shuffled batches so that we can minimize issues with not enough RAM\n- The `df.pivot` function can reformat tables!\n- To use PyTorch for ML, we want to have a DataSet (ds) and a DataLoader (dl)\n    - The DataSet is a clean, raw representation of the data that we are using\n    - The DataLoader basically helps enumerate and access the DataSet\n        - Can help with creating batches and shuffling\n```python {title=\"basic training loop\", linenos=false}\nmodel = torch.nn.Linear(1, 1)\noptimizer = torch.optim.SGD([model.weight, model.bias], lr=0.00001)\nloss_fn = torch.nn.MSELoss()\n\nfor epoch in range(50):\n    for batchx, batchy in dl:\n        predictedy = model(batchx)\n        loss = loss_fn(batchy, predictedy)\n        loss.backward()   # update weight.grad and bias.grad\n        optimizer.step()  # update weight and bias based on gradients\n        optimizer.zero_grad()  # weight.grad = 0 and bias.grad = 0\n\n    # how well are we doing?\n    x, y = ds[:]\n    print(epoch, loss_fn(y, model(x)))\n```\n\n\n### (threads)\n- Simple Python programs use at most ONE core so speed is capped by how much work one core can do\n- A **process** is a running program which has its own **virtual address space (VAS)**\n    - The process cannot directly access physical memory\n    - A VAS can have holes\n![Processes and address spaces](/images/image-2.png)\n- A CPU core can be pointed at one instruction in the code at any time\n    - Each core has its own cache\n- Threads have their own instruction pointers and stacks, but share the heap\n    - Single-threaded processes have one pointer, multi-threaded processes have multiple pointers\n- Context switch: switching between threads -- doing it too much is slow\n![Context switch](/images/image-3.png)\n- Race conditions: when two threads both access a shared variable and problems occur\n\n\n### (locks)\n- Two threads can be interleaved and executed in a way that causes information to be lost\n    - Modifying global variables and loading/storing simultaneously\n- We want atomicity -- if it happens, then it happens together (otherwise not at all)\n- A **lock** (`threading.Lock()`) is held by only one thread at a time and protects critical sections from being inturrupted\n    - Putting locks in the wrong places can still cause errors so the importantthing is to be careful / generous with where you're putting locks\n    - Locking and releasing is also an expensive operation!\n- If an exception occurs before the lock is released, then the code will never execute because the lock is still active\n    - Use `with` statements\n\n---\n\n## network resources\n### (RPC)\n- Every Network Interface Controller (NIC) has their own unique Media Access Control (MAC) address\n    - Some devices randomly change or mask their MAC addresses for privacy (there are some good papers on this)\n    - Computers can only send messages to other computers which are on the same network\n- An **internet** is just a group of networks; the Internet is the global one...?\n- A **packet** is a group of bytes that has an IP address which is its destination location\n- Private networks allow for duplicate IPv4 addresses\n![private networks example](image.png)\n- Network Address Translation (NAT) boxes can help you forward public IP addresses into private IP addresses in a network\n- Different port numbers on the same IP address can be running different servers\n- There are two main transport protocols:\n    - TCP: reliable - will guarantee that the message is sent in the original order and will try to resend lost packets\n    - UDP: unreliable - doesn't do extra work, just sends the packet\n- HTTP methods: POST (create new), PUT (update), GET (fetch), DELETE for dealing with HTTP messages\n- RPC stands for Remote Procedure Call -- calling a function remotely\n    - gRPC, which helps with calling functions on a server, is built on top of HTTP\n- With RPCs, the code can be in different languages, so there needs to be a universal representation for types\n    - Serialize (encode) and deserialize (decode) the types using a table -- this is called protobufs\n    - What do we have to take into consideration? Types, byte order, encoding length\n![protobuf table](image-1.png)\n- Make a `.proto` file to define messages that are being sent between two computers, then run gRPC on it to create classes\n    - The classes are automatically generated in the specified language\n    - The messages are basically objects that you can create\n```proto {title=\"Example proto file for multiplying two numbers together\", linenos=false}\nsyntax = \"proto3\";\n\nservice Calc {\n    rpc Mult(MultReq) returns (MultResp)\n}\n\nmessage MultReq {\n    int32 x = 1;\n    int32 y = 2;\n}\n\nmessage MultResp {\n    int32 result = 1;\n}\n```\n- To call a function, you have to define an RPC in the format `rpc NAME(ARGUMENTS), returns (RETURN VALUE);` as a part of a service inside the `.proto` file\n\n---\n\n## storage resources\n### (file systems)\n- **Block devices** are long term storage devices that are accessed in units of blocks\n- Caching is for storing data that might be accessed later, buffers mostly pertain to minimizing function calls for the same data, storing one large block/page of data when lines are being read one at a time\n- Small reads (\u003c4KB):\n    - No good way to read only one column without also reading everything else\n    - The whole block has to be accessed to get a small portion of data\n- **Hard disk drives (HDDs):**\n    - Steps to transfer data:\n        1. Move pointer to correct track\n        2. Wait for disk to rotate until data is under head\n        3. Transfer data\n    - For transferring small amounts of data, then the first two steps will dominate the processing time\n    - Solution: assign sequential block numbers for HDDs\n- **Solid state drives (SSDs):**\n    - No moving parts and can read data in parallel\n    - Blocks and pages are used in different context than HDDs\n    - Erase content in blocks, write content in pages, but can't rewrite to individual pages\n    - To rewrite content, SSDs just put it somewhere else and it needs to be tracked\n![rewriting SSDs](/notes/image-19.png)\n- Block devices can be divided into partitions\n- Redundant Array of Inexpensive Disks (RAID) controllers can make multiple devices look like one device\n- Local file systems can track files by segmenting them into blocks and tracking which blocks are relevant to the file -- this is called an inode structure\n    - Directories contain inode mappings and names of files\n- Each drive has its own file system \"tree\"\n![file tree](/notes/image-20.png)\n\n### (formats and DBs)\n- Files store sequenes of bytes, but how do we organize the bytes in a useful format?\n    - CSVs are row oriented\n    - Parquets are column oriented\n- Choosing a file format depends on how we want to access the data\n    - Transactions processing: reading or writing rows as needed\n    - Analytics processing: computation over many rows to get specific columns\n- Parquets are much faster and the preferred data type for analytics processing!\n- Protobufs are the best way to get the smallest amount of bytes used for a piece of data\n- Compression is the idea of avoiding repetition in datasets\n    - Parquets use snappy compression which prioritizes high speed over maximum compression\n- Schema is the structure of the dataset, like the types and field names\n- Databases have a bunch of tables which a user can query to get specific data back\n    - SQL is the most popular querying language\n    - Large DBs are usually only fast at either transactions or analytics, but not both\n    - DB types: online transactions processing (OLTP) typically row oriented, online analytics processing (OLAP) typically column oriented\n    - Extract-transform-load (ETL) is the process of transferring data from OLTPs into OLAPs\n![dbms](/notes/image-21.png)\n\n---\n\n# clusters and hadoop ecosystem\n\n\n\n# further reading\n- Linear Algebra and Learning From Data by Gilbert Strang\n- Machine Learning with PyTorch and Scikit-Learn","lastmodified":"2023-08-24T05:02:02.331071971Z","tags":[]},"/notes/cs61a":{"title":"CS 61A","content":"Self-paced course taken summer '22, linked [here](https://inst.eecs.berkeley.edu/~cs61a/fa21/). Beginner programming course using Python -- teaches data abstraction, ... Great focus on shortcuts and problem-solving with code; has hints of competitive coding strategies. Texts used include *Composing Programs* by John DeNero. Completed homework linked [here](https://github.com/heyitssqueak/classes/tree/master/cs61a).\n\n# content\n\n## functions\n\n### ch1.1: getting started\n\n- Python devs emphasized human interpretability of Python code ‚Äî easy to read/understand\n- an interactive session is signaled by the `\u003e\u003e\u003e`\n- statements describe actions; expressions describe computations\n\n### ch1.2: elements of programming\n\n- any powerful programming language should be able to describe data and functions, or, ‚Äúhave data and process it‚Äù\n- expressions describe a computation and evaluates it to a value\n    - infix notation is when operators (`+`, `-`, `*`, `/`) appear between operands (the numbers)\n    - all expressions can be generalized to **function notation**\n- a **call expression** applies a function to some arguments\n- not all functions are available by default and many have to be imported through **modules**\n- `=` is the assignment operator, which matches names to the results of compound operations or to functions\n    - the names are remembered by Python‚Äôs interpreter, which means that the interpreter has some kind of memory ‚Äî the memory is an **environment**\n- nested function calls repeated the same procedure until the expression is evaluated: first evaluate the operator (function) and then its operands (arguments)\n- **pure functions** have an input and an output and will *always return the same output for the same input*\n    - can‚Äôt have side effects or change behavior over time, making them reliable\n    - simpler to test\n- **non-pure functions** change the state of the interpreter or computer, ex: `print`\n- a function that doesn‚Äôt specify a return value will return `None`\n\n### lecture\n\n- every expression in Python is generalized to *function call notation*\n- any call expression is made up of an operator and its operands, which are also expressions (possibly made up of more operators and operands)\n\n![call expression tree](/images/cs61a/call-expression-tree.png)\n\n- three ways to bind values to names: importing modules, assignment, and `def` statements (functions)\n- with a frame, a name can only be bound to one value\n- Python evaluates all the expressions to the right of the assignment operator `=`, and then it binds the resultant values to the name(s) on the left\n- **abstraction** is the process of naming something complex and treating it as a whole entity without worrying about its details\n    - functions are a form of abstraction:\n        ```python\n        def \u003cname\u003e(\u003cformal parameters\u003e):\n            return \u003creturn expression\u003e\n        ```\n        - the function *signature* (first line) defines how many arguments a function will take ‚Äî the signature is the name of the object\n        - the function *body* (remainder) is where the computational process happens\n- an *environment* is a sequence of *frames*\n    - a **frame** is a bit of a memory that keeps track of what names mean (it‚Äôs also called a scope)\n    - any name evaluates to the assigned value in the closest frame, starting with the local frame and working towards the global frame\n- to use a local variable from the global frame, you have to return the local variable first (assuming it‚Äôs a function call)\n\n---\n\n## control\n\n### ch1.3: defining new functions\n\n- to define a function is to give a name to a compound operation, which allows the operation to be referred to\n- the `def` statement and the assignment operator `=` bind names to values ‚Äî any previously bindings are lost\n- bindings exist in *frames* which are layered\n    - a local frame is created every time a function is called\n        - a name only exists in that frame for as long as the frame exists, ie once the function call is over, any bindings within the function will disappear\n- the **scope** (existence) of a local name is limited to its function or its frame\n- functional abstraction is the idea that the only thing that matters about a function is its return value, and not the process which that value is computed\n    - three core values to functional abstraction: *domain*, or the set of arguments of a function; *range*, or the set of values it can return; *intent*, the relationship between the inputs and outputs\n\n### ch1.4: designing functions\n\n- a function should have exactly one job\n- don‚Äôt repeat yourself ‚Äî if you are copy-pasting code, it can probably be turned into a function\n- triple quoted docstrings at the top of a function body typically describe what the function does\n    ```python\n    def pressure(v, t, n):\n        \"\"\"Compute the pressure in pascals of an ideal gas.\n    \n        Applies the ideal gas law: http://en.wikipedia.org/wiki/Ideal_gas_law\n    \n        v -- volume of gas, in cubic meters\n        t -- absolute temperature in degrees kelvin\n        n -- particles of gas\n        \"\"\"\n        k = 1.38e-23  # Boltzmann's constant\n        return n * k * t / v\n    ```\n- default function values can be specified in the function signature\n\n[stopped reading the textbook lol]\n\n### lecture\n\n- Python‚Äôs interactive interpreter will print any value returned from an expression or function that isn‚Äôt `None`, which represents nothing\n- **pure functions** return values and have the same output for the same input\n- **non-pure functions** have an input and output but something else happens before the output, like some text being printed to the terminal\n- a `def` statement is how a function is created ‚Äî includes the signature and body, which are bound to the name of the function\n    - the frame isn‚Äôt created until the function is called\n- multi-frame environments consist of a global frame and then local frames\n    - a *name* evaluates to the earliest assigned instance of a value to that name, whether that be in the local frame or otherwise\n- there are two kinds of division\n    - `/` is called **true division** which divides like normal, ex: `2013 / 10` evaluates to `201.3`\n    - `//` is called **floor division** which rounds down to the nearest integer, ex: `2013 / 10` evaluates to `201`\n- to return multiple values from a function, use a comma\n- Python can run in a file, run in the interactive mode, or run a file in interactive mode\n- Python can run an interactive session by taking code from a function‚Äôs docstring\n    ```python\n    def divide_exact(n,d):\n        \"\"\"Return the quotient and remainder of dividing n by d.\n    \n        \u003e\u003e\u003e q, r = divide_exact(2013, 10)\n        \u003e\u003e\u003e q\n        201\n        \u003e\u003e\u003e r\n        3\n        \"\"\"\n        return floordiv(n, d), mod(n, d)\n    \n    python3 -m doctest -v [\"filename\"]\n    ```\n- use the `if`, `elif`, `else` to execute a suite (set of statements after a header) that evaluate to true to a boolean statement\n- **boolean statements** will always evaluate to either `True` or `False`\n    - false values: `False`, `0`, `\"\"`, `None`\n    - true values: anything that isn‚Äôt false\n- **iteration** allows us to repeat stuff\n    - for a `while` loop, we evaluate the header‚Äôs boolean expression, and then execute the following suite and evaluate the header again\n\n---\n\n## higher-order functions\n\n- characteristics of functions\n    - **domain**: the set of all inputs as arguments\n    - **range**: the set of all outputs\n- each function should have exactly one general job\n- an `assert` keyword can be followed by a boolean expression that will throw an error if the expression evaluates to false\n    - this is useful for checking if given arguments are within specifications\n- a higher-order function is a **first-class value**, and can take another function as an argument, or can also be returned as a return value\n    ```python\n    def make_adder(n):\n        \"\"\"Return a function that takes one argument k and returns k + n.\n    \n        \u003e\u003e\u003e add_three = make_adder(3)\n        \u003e\u003e\u003e add_three(4)\n        \"\"\"\n        def adder(k):\n        \treturn k + n\n        return adder\n    ```\n    - the function `adder` is returned from `make_adder` and assigned to `add_three` with `n=3`\n- **lambda expressions** are expressions that evaluate to *functions* ‚Äî use the `lambda` keyword, ex: `square = lambda x: x*x` ‚áí `square(4)` evaluates to 16\n    - the function name can be skipped and directly called, ex: `(lambda x: x*x)(4)` evaluates to 16\n- lambdas can‚Äôt use conditionals while `def` statements can; `def` statements give functions a name while lambdas don‚Äôt (it‚Äôs just called a lambda)\n- `and` and `or` are logical operators which don‚Äôt require all statements to be checked to evaluate fully\n    - for `and`, if the first statement is false, then the whole statement is false\n    - for `or`, if the first statement is true, then the whole statement is true\n        - ex: `return (n==0) or (1/n != 0)`, the expression wouldn‚Äôt throw a zero-division error because `n==0` evaluate to true first so true is returned without considering the second expression\n- a conditional expression can take the form `\u003cconsequent\u003e if \u003cpredicate\u003e else \u003calternative\u003e`\n    - the `\u003cpredicate\u003e` is evaluated first, and if it‚Äôs true, the expression evaluates to the `\u003cconsequent\u003e` value\n    - if `\u003cpredicate\u003e` is false, then the expression evaluates to `\u003calternative\u003e`\n    ```python\n    print(\"cons\" if 2==2 else \"alt\")\n    # prints cons\n    print(\"cons\" if 2==3 else \"alt\")\n    # prints alt\n    ```\n    \n---\n\n## environments\n\n- a **higher-order function** is a function that can take another function as an argument, or returns another function as a return value\n- a return statement brings information from a local frame into a global frame (or similar)\n- the parent frame of a frame created from a *returned function* is the *frame where that function was created*, which means that function has access to its parent frame values\n    - below: `make_adder` returns a function `adder` in frame `f1`; when the new `add_three` function (a sub-function of `adder`) is called, it can access values in its parent frame, `f1`\n\n![python tutor frames](/images/cs61a/parent-frames.png)\n\n- the environment created by calling a top-level function consists of a local frame followed by the global frame\n- a function can return itself, which can lead to the same function being called on multiple arguments in the same line of code\n    - the function does not run forever because the return value is only a function object, and not a call to that function\n    ```python\n    def print_all(x):\n        print(x)\n    \treturn print_all\n    \n    print_all(1)(3)(5)\n    \n    # 1\n    # 3\n    # 5\n    ```\n- **currying** is transforming a multi-argument function into a single-argument, higher-order function\n    - when calling `add_three`, it has access to the `f2` and `f1` frames which store the variables `x` and function `f`\n\n![currying](/images/cs61a/currying-frames.png)\n\n---\n\n## design\n\n- **abstraction** is giving a name to a process and referring to it as a whole and not worrying about the details of the process\n    - function names don‚Äôt matter for correctness of a program, but they matter to humans :(\n- a **docstring** is the best way to document a function‚Äôs purpose\n- a **syntax error** is detectable before the program starts executing and they are caused by errors in the form/language of the code, ex: unclosed parentheses\n- a **runtime error** is detected by the interpreter while the program is executing, ex: `TypeError` which occurs when math doesn‚Äôt work out between objects of different types‚Ä¶\n- a **logical error** isn‚Äôt detected at all, the program runs but doesn‚Äôt do as expected\n- a **decorator** is a function that goes at the top of a function, which is called on the function\n    ```python\n    @trace\n    def triple(x): # calls trace on triple\n        return 3*x \n    ```\n\n---\n\n## recursion\n\n- a **recursive function** is a function that calls itself\n    - uses conditional statements to check for base cases ‚Äî usually doesn‚Äôt end in a recursive call, and a value is directly returned\n    - each call to the function will solve a simpler problem than the last call (smaller `n`)\n- mutual recursion is when two different functions call each other, ex: Luhn algorithm\n- iteration is a special case of recursion\n    - to convert from recursion to iteration, you need to figure out what *state* has to be maintained after each recursive call (which should match to each iterative call‚Ä¶)\n\n---\n\n## tree recursion\n\n- until a value is returned from a function call, that call is not completed\n- statements can happen before and after recursive calls\n- **tree-shaped recursion** happens when the body of a recursive function calls itself more than once\n    - ex: computing a Fibonacci number `n` requires finding the Fibonacci number at `n-1` and `n-2`\n    ![fib tree recursion](/images/cs61a/fibtree.png)\n- some problems are best resulted by a recursive function‚Ä¶\n- counting partitions example ‚Äî looks like a competitive programming problem\n    - Given a number `n`, using parts of up to size `m`, find the number of ways that `n` can be represented as a sum of positive integer parts with size `m` in increasing order; ex: `count_partitions(6,4)` means we should find all the possible ways that we can form 6 using parts of up to size 4. (2+4, 1+1+4, 1+2+3, 1+1+2+2‚Ä¶)\n    ```python\n    def count_partitions(n,m):\n        if n == 0:\n            return 1\n        elif n \u003c 0:\n            return 0\n        elif m == 0:\n            return 0\n        else:\n            with_m = count_partitions(n-m, m)\n            without_m = count_partitions(n, m-1)\n            return with_m + without_m\n    ```\n\n---\n\n## containers\n\n- a **list** is a built-in data type that can hold a group of any objects\n    - has indexing using brackets and `len` function for the length of the list\n    - multiplying a list forms a repetition of the list, while adding two lists together merges them into one list\n    - to test if an element appears in a *container*, use the `in` keyword\n        - if the element is nested too deeply (more than one layer‚Ä¶?) then `in` can‚Äôt find it ‚Äî it only looks at each element of the list\n- a `for` statement can iterate through a list or a range of numbers\n    ```python\n    for \u003cname\u003e in \u003cexpression\u003e:\n        \u003csuite\u003e\n    ```\n    - a sequence can be unpacked in the `for` statement, ex: each value in the nested list `pairs=[[4,4],[3,5],[1,2]]` can be assigned to a variable using `for x, y in pairs`\n- a **range** is also a sequence type, like a list, but represent consecutive integers\n    - convert a range to a list using the `list` function\n- list comprehensions are shortcuts to generate new lists from existing lists\n    ```python\n    odds = [1,3,5,7,9]\n    evens = [x+1 for x in odds] # list comprehension\n    # [2,4,6,8,10]\n    \n    div_25 = [x for x in odds if 25 % x == 0] # only added to the list if the condition evaluates true\n    # [1,5]\n    ```\n- **strings** are a way of representing data\n    - `\\n` represents a new line\n    - `len` and indexing can also be used\n    - `in` evaluates to substrings which means you can look for whole words\n\n---\n\n## sequences\n\n- a method for combining data values satisfies the **closure property** if the *result* of the combination can be itself combined using *the same method*\n    - two lists can be combined using the `+` operator, whose result can be added to another list!\n    - important for creating hierarchical structures\n- **slicing** is an operation that can be performed on lists and ranges ‚Äî it uses the `[lower:upper]` notation, ex: `\"berkeley\"[0:3]` returns `\"ber\"`\n    - always creates new objects\n- `sum` will add all non-string values in a list together with an optional parameter as the start value of the summation\n- `max` will return the maximum value of the sequence and takes an optional function `key` as a parameter that can be applied to all values to find the max of that function, ex: `max([1,2,3,4,5], key=lambda x: 7-(x-4)*(x-2))` returns `3`\n- `all` returns if all values in an iterable will return true\n\n---\n\n## data abstraction\n\n- abstract data types allows us to manipulate compound objects as units, which separates how data is represented and manipulated\n    - **constructors** build abstract data values\n    - **selectors** work with parts of the abstract data values\n- a list can be unpacked, ex: `x,y = [1,2]` where `x=1` and `y=2`\n- abstraction barriers allow parts of the program to take advantage of other parts of the program without anything causing errors between them ‚Äî certain parts only use certain functions‚Ä¶\n\n![abstraction](/images/cs61a/abstraction.png)\n\n- data types guarantee that the constructor and selectors will work together to show the right behavior\n- data abstraction can be implemented as functions\n- **dictionaries** are a built-in data type that assigns a value to a key ‚Äî sequence of keys\n    - created using curly brackets, ex: `{key:value}`\n    - look up values by looking up the name of the key between square brackets (indexing with key names)\n    - the value in a dictionary can be any object\n    - keys cannot be repeated and the key itself can‚Äôt be a list or dictionary\n- dictionary comprehensions can generate dictionaries given a ruleset\n    ```python\n    {\u003ckey exp\u003e: \u003cvalue exp\u003e for \u003cname\u003e in \u003citer exp\u003e if \u003cfilter exp\u003e}\n    \n    {x * x: x for x in [1,2,3,4,5] if x \u003e 2}\n    # {9: 3, 16: 4, 25: 5}\n    ```\n\n---\n\n## trees\n\n- **trees** represent hierarchical relationships\n    - a tree has a root and a list of branches (which are subtrees)\n    - a leaf is a tree without any branches\n\n![tree diagram](/images/cs61a/tree-diagram.png)\n\n```python\ndef tree(label, branches = [])\n    for branch in branches:\n        assert is_tree(branch), \"branches must be trees!\"\n    return [label] + list(branches)\n\ndef label(tree):\n    return tree[0]\n\ndef branches(tree):\n    return tree[1:]\n\ndef is_tree(tree):\n    if type(tree) != list or len(tree) \u003c 1:\n        return False\n    for branch in branches(tree):\n        if not is_tree(branch):\n            return False\n    return True\n\ndef is_leaf(tree)\n\t\treturn not branches(tree)\n```\n- functions that take trees as inputs or returns trees as outputs are **tree-recursive**\n    - example with a function that counts the leaves of a tree\n        ```python\n        def count_leaves(t):\n            \"\"\"Count the leaves of a tree.\"\"\"\n            if is_leaf(t):\n                return 1\n            else:\n                branch_counts = [count_leaves(b) for b in branches(t)]\n                return sum(branch_counts)\n        ```\n- information can either be passed through recursive calls as arguments or they can be manipulated as return values\n\n---\n\n## mutability\n\n- an object is supposed to behave like what it represents (information)\n    - it has attributes, which are like details of the object\n    - methods are accessed using a dot expression and are applied on the object\n    - a type of object is called a **class**\n- functions are meant to do one thing; objects are meant to do many related things\n- strings are objects, with methods `.upper` `.lower`, attributes `len`\n- an object‚Äôs value can change over time\n    - lists can be mutated (changed) using `.remove` `.pop` `.append` etc, which will be reflected in any copies of that list\n    - mutable objects include lists and dictionaries\n- **tuples** are immutable sequences and are created using parentheses `()`\n    - tuples can be added and sliced like lists\n    - they are immutable, so they *can* be used as keys (unless they contain lists or dicts)\n- an immutable sequence can still change if it has a mutable value as an element\n- the identity operator is `is` and will evaluate to true if both expressions evaluate to the same object ‚Äî this is different from equality (`==`) which is true when both expressions evaluate to the same *value*\n    - when two things aren‚Äôt identical, changes in one won‚Äôt affect the other\n\n---\n\n## syntax\n\n- **syntax** is like the rules for how a language works\n- read plaintext files in Python using `open` and `readlines`\n- useful string methods: `.strip` `.split` `.replace`\n- language models describe how likely some text would appear in a sentence or next to some words (generating sentences by looking at huge samples of data)\n\n---\n\n## iterators\n\n- **iterators** represent sequential data, which provides access to elements in some order\n    - `iter` returns an iterator of some iterable value\n    - `next` returns the next value in an iterator\n- after Python 3.6, the order of items in a dictionary is the order which they were added\n- useful dictionary methods: `.keys` returns a list of keys, `.values` returns a list of values, `.items` returns a list of tuples containing key and value\n- if a dictionary key is changed while it‚Äôs being iterated over, then the iterator is now invalid ‚Äî doesn‚Äôt apply if a dictionary value is changed\n- `for` statements can iterate over iterators\n- built-in functions for iteration\n    - `map(func, iterable)` applies `func` to `x` for `x` in `iterable`\n    - `filter(func, iterable)` iterates through `x` in `iterable` if `func` is true\n    - `zip(iter_1, iter_2)` iterates through pairs\n    - `reversed(seq)` iterates in reverse order\n    - `list` `sorted` `tuple`\n- lazy computation is useful if you need to calculate lots of values but don‚Äôt need all the values immediately\n- calling `iter` on an iterable just returns that iterable object\n\n---\n\n## generators\n\n- a **generator** is a special kind of iterator, returned from a generator function which uses the `yield` keyword instead of `return`\n    - the generator object can yield (return) multiple values and the generator function iterates through them\n    ```python\n    def plus_minus(x):\n        yield x\n        yield -x\n\n    t = plus_minus(3) # t is a generator object\n    next(t) #  3\n    next(t) # -3\n    ```\n    - the body of the generator function isn‚Äôt called until `next` is called\n- `yield from` just yields all the values in an iterator ‚Äî is shorthand for using `for` statements\n- example of finding all substrings of a string‚Ä¶ looks like a competition problem\n    ```python\n    def prefixes(s):\n        if s:\n            yield from prefixes(s[:-1])\n            yield s\n    \n    def substrings(s):\n        if s:\n            yield from prefixes(s)\n            yield from substrings(s[1:])\n    ```\n- if there is a `return` statement in a generator, it won‚Äôt yield anything after\n- repeating the partitions problem but using `yield`\n    ```python\n    def partitions(n, m):\n        if n \u003e 0 or m \u003e 0:\n            if n == m:\n                yield str(m)\n            for p in partitions(n-m, m):\n                yield p + \" + \" + str(m)\n            yield from partitions(n, m-1)\n    ```\n\n---\n\n## objects\n\n- **object-oriented programming (OOP)** is a way of organizing programs so that similar information and behavior are grouped together, and can be changed without affecting other parts of the program (abstraction)\n- a **class** is a template for its instances, which are objects of that class\n    - all objects part of a class will have the same attributes and behaviors\n- `class` statements let you create a new class, which means you can create your own objects\n    ```python\n    class \u003cname\u003e:\n        \u003csuite\u003e\n    ```\n    - assignments and `def` statements within the `\u003csuite\u003e` create attributes of the class\n- when a class is called, a new instance of the class is created (a new object)\n    - the `__init__` method is first called with an argument `self` and any other specified arguments\n    ```python\n    class Account:\n        def __init__(self, account_holder):\n            self.balance = 0\n            self.holder = account_holder\n    ```\n- binding an object to a new name using assignment does *not* create a new object‚Ä¶\n- **methods** are functions that are defined in a class\n    ```python\n    class Account: \n        def deposit(self, amount):\n            self.balance = self.balance + amount\n\n        def withdraw(self, amount):\n            if amount \u003e self.balance:\n                return \"Insufficient funds.\"\n            self.balance = self.balance - amount\n            return self.balance\n    ```\n- `self` is referring to an (arbitrary?) instance of the class, similar to `this` in Java\n- any object has access to its attributes (via the `self` keyword) ‚Äî they can be accessed using *dot notation* `\u003cexpression\u003e.\u003cname\u003e`\n    - can also get attributes using function `getattr(obj, attr)`\n- a **method** is an attribute that‚Äôs a function\n    - **bound methods** group together the function and the object which the method is called on\n\n![instance and class methods](/images/cs61a/method-types.png)\n\n- class attributes are shared across the class ‚Äî if it changes, then it changes for every instance of the class\n    ```python\n    class Account:\n        interest = 0.02 # class attribute\n    ```\n\n---\n\n## inheritance\n\n- all objects, including classes, have attributes\n    - an attribute of an instance is called an *instance attribute*, ex: `\u003cinstance\u003e.attribute =`\n    - attribute of a *class* of an instance is called a *class attribute*, ex: `Class.attribute =`\n        - changing class attributes doesn‚Äôt change individual attributes\n- **inheritance** is a method for relating classes together\n    ```python\n    class \u003cname\u003e(\u003cbase class\u003e):\n        \u003csuite\u003e\n    ```\n    - the subclass can share attributes with its base class\n    - methods from base classes can be called by calling the base class‚Äôs attribute\n- **composition** is when one object has another object as an attribute\n- inheritance: is-a relationship, ex: `CheckingAccount` is a `Account`; composition: has-a relationship, ex: `Bank` has a `Account`\n- **multiple inheritance** is when a subclass has multiple base classes ‚Äî should be used sparingly\n\n---\n\n## representation\n\n- the `str` string representation is designed for human readability, while the `repr` string representation is designed for the Python interpreter\n    - calling `repr` on a value will show what would print out in an interactive session, ex: `repr(min)` shows `'\u003cbuilt-in function min\u003e'`\n- **string interpolation** is when you evaluate a string literal with some expressions\n    - add `f` before the string and enclose any expressions in curly braces, ex: `f'pi starts with {pi'`\n- a **polymorphic function** is a function that applies to many types of data (such as `str` and `repr`)\n- an **interface** is a set of shared messages (attributes look-ups that elicit similar behaviors even on different classes/types)\n- certain method names are special because they have a built-in behavior ‚Äî denoted by two underscores, like `__init__`, `__repr__`\n    - adding two instances of user-defined classes: `__add__` or `__radd__` but you have to define it\n\n---\n\n## recursive objects\n\n- a **linked list** is either empty or it just holds a single value with a reference to the rest of the list ‚Äî it‚Äôs just like a number line thing\n\n![linked list diagram](/images/cs61a/linked-list-diagram.png)\n\n- the rest attribute of a linked list can be assigned to an earlier element in that list, which creates a loop in the list\n- *rerouting* in a linked list is reassigning the rest attribute which would change the list (either when you‚Äôre adding or removing instances)\n- a path (for a tree data structure) is a sequence of nodes that leads to a certain node\n- *pruning* is removing subtrees from a tree\n\n---\n\n## efficiency\n\n- it‚Äôs important for programs to not take up too many resources while running\n- **memoization** is the idea that you should remember the results that have been computed previously (so they can be used later)\n    ```python\n    def memo(f):\n        cache = {}\n        def memoized(n):\n            if n not in cache:\n                cache[n] = f(n)\n            return cache[n]\n        return memoized\n    ```\n    \n    - only pure functions can be memoized\n- complexity can sometimes mean better efficiency\n- there is *linear* and *logarithmic* orders of growth, or how long the function takes to run as the numbers get larger ‚Äî also *quadratic* for pairs of inputs, or *exponential* for recursion, and *constant* growth means the input doesn‚Äôt affect the time\n    - there is a notation for each order of growth, called big-theta (or big-O for upper bound) notation\n    - exponential: $O(b^n)$; quadratic: $O(n^2)$; linear: $O(n)$; logarithmic: $O(\\log n)$; constant: $O(1)$\n- the length of objects/programs take up space (memory), but so do active frames and environments\n    - an active environment includes current active function calls, including their parents (this might be why recursion is slow?)\n\n---\n\n## decomposition\n\n- **modular design** is when a big program is broken up into smaller, independent parts ‚Äî parts can be swapped out and implement abstraction barriers\n    - a component is meant to do one thing and can be developed and tested independently\n    - one part should know as *little as possible* about the other parts, so changes in one component won‚Äôt break everything else\n- read json files in Python by importing the `json` module and then opening the file using `open` and reading the lines\n- given two, non-repeating sorted lists, advance the iterator over the smaller value until a pair is found, then iterate both, until the end of the list is reached (linear time)\n\n---\n\n## users - todo\n\n---\n\n## scheme\n\n- **scheme** is a dialect of lisp\n- programs consists of expressions\n    - primitive: 2, 3.3, true, +\n    - combinations: `(quotient 10 2)` `(not true)`\n- procedures = functions\n- the built-in `?` operator can evaluate if something is of a certain type ‚Äî `(zero? 0)` is `#t`, `(zero? 1)` is `#f`\n- special forms\n    - `(if \u003cpredicate\u003e \u003cconsequent\u003e \u003calternative\u003e)`\n    - `(and \u003ce1\u003e ... \u003cen\u003e)`, `(or \u003ce1\u003e ... \u003cen\u003e)`\n    - symbols: `(define \u003csymbol\u003e \u003cexpression\u003e)`\n    - procedures: `(define (\u003csymbol\u003e \u003cformal parameters\u003e) body)`\n        ```scheme\n        (define (sqrt x)\n            (define (update guess)\n                (if (= (square guess) x)\n                    guess\n                    (update (average guess (/ x guess)))))\n            (update 1)\n        ```\n    - `(lambda (\u003cformal-parameters\u003e) \u003cbody)`\n- `cond` is like an if/else or a switch statement\n    ```scheme\n    (cond ((\u003e x 10) (print 'big)) ; only one is executed\n          ((\u003e x 5)  (print 'medium))\n          (else     (print 'small)))\n    ```\n    \n- `begin` allows you to add multiple subexpressions to be evaluated if a condition evaluates to true‚Ä¶\n- `let` binds a temporary symbol to a value, which is gone after it is used ‚Äî `define` is used for permanent things\n- every scheme list is a linked list\n    - `cons` creates a linked list\n    - `car` returns the first element of the list\n    - `cdr` returns the rest of the list ‚Äî usually returns a list too?\n    - `nil` is the empty list\n- `list` just builds a list without needing to use `cons` but the underlying `car` `cdr` is still the same\n- symbols refer to values, but how do we refer to symbols? by using `'` quotation, ex: `(list 'a 'b)` makes `(a b)`\n    ```scheme\n    (define a 1)\n    (define b 2)\n    (list a b)\n    ; (1 2)\n    (list 'a 'b)\n    ; (a b)\n    (list 'a b)\n    ; (a 2)\n    ```\n    - a symbol can be used as a part of the code without calling the actual function\n\n---\n\n## exceptions\n\n- an example of how symbols can be used\n    ```scheme\n    (list 'quotient 10 2)\n    ; (quotient 10 2)\n    \n    (eval (list 'quotient 10 2))\n    ; 5\n    ```\n- build lists to write constructed code and just call `eval` when you need to run the code\n    - using symbols tells scheme that we don‚Äôt want to evaluate the expression yet\n- quasiquotation is when you can use a special backtick quote symbol ``` and parts of the quote can be unquoted with `,`\n    - quote: `'(a ,(+ 3 1))` \u003e `(a (unquote (+ 3 1))`\n    - quasiquote: ``(a ,(+ 3 1))` \u003e `(a 4)`\n- `while` statements don‚Äôt exist in scheme so you have to iterate and you recursion\n- quoting, unquoting, and the structure of lisp/scheme allow for the computer to easily generate programs\n- Python raises exceptions when errors occur, which can also be handled ‚Äî unhandled exceptions will halt Python and print stack traces\n    - `assert` statements ‚Äî ignore assertions using the `-O` flag\n    - `raise` statements are exceptions with custom debug messages\n- `try/except` suites can handle exceptions when they are expected\n    - the `try` suite is executed first, and if an unhandled exception is raised and inherited from the exception class in the `exception` suite, then the `exception` suite is executed\n    ```python\n    try:\n        \u003ctry suite\u003e\n    except \u003cexception class\u003e as \u003cname\u003e:\n        \u003cexcept suite\u003e\n    ```\n    \n---\n\n## calculator\n\n- an **interpreter** is a program that takes code as an input and executes the code to get the desired output\n- **machine languages** are languages that are interpreted by the hardware ‚Äî instructions based on the circuitry of the CPU\n    - hard to program, no abstraction, usually refer to specific memory addresses\n- **high-level languages** are statements and expressions that are translated into another language to be executed later\n    - provides abstraction, functions, objects\n    - no hardware designed for these languages\n- some languages are designed for a specific application ‚Äî Erlang was designed for concurrent communication, MediaWiki was designed for static web pages\n- languages have syntax (statements/expressions) and semantics (execution/evaluation)\n    - need to have specification or a canonical implementation\n- a **parser** takes text and returns expressions\n\n![parse order](/images/cs61a/parse-order.png)\n\n- recursive syntactic analysis is a process of inspecting `k` tokens to decide how to proceed, for a fixed `k`...\n    - the base case is symbols and numbers, any other calls are sub-expressions\n- the `Pair` class represents Scheme pairs and lists ‚Äî has first and second attributes\n    - will be a well-formed list if second is nil or a well-formed list\n- primitive (numbers) expressions evaluate to themselves while call expressions evaluate to its arguments modified by an operator\n- **read-eval-print loop** allows a person to interact with the code, ie Python interactive interpreter\n    - exceptions are handled in one place and should not stop the interactive interpreter\n\n---\n\n## interpreters\n\n- an `eval` evaluates both primitive and combined expressions, but will call a function `apply` on the combined expressions\n    - `apply` will also call `eval` to evaluate the body of custom functions which makes mutually recursive functions\n\n---\n\n# homework\n\n### disc 01: control, environment diagrams\n\n- **conditional statements** let programs execute different lines of code depending on what conditions are true or false\n    - general form of an `if` statement\n        ```python\n        if \u003cconditional expression\u003e:\n            \u003csuite of statements\u003e\n        elif \u003cconditional expression\u003e:\n            \u003csuite of statements\u003e\n        else:\n            \u003csuite of statements\u003e\n        ```\n    - general form of a `while` loop\n        ```python\n        while \u003cconditional clause\u003e:\n            \u003cstatements body\u003e\n        ```\n        \n- `not` `and` `or` are boolean operators that manipulate boolean expressions\n- a `def` statement defines a function object\n    - call expressions apply functions to arguments\n\n### lab 01: variables \u0026 functions, cont\n\n- `\u003e\u003e\u003e True and 12` displays `12`\n- `\u003e\u003e\u003e False or 0` displays `0` (I assume because the statement evaluates to `False` and `0` is the last evaluated expression?)\n- `\u003e\u003e\u003e not 10` displays `False` because `10` is a truthy value\n- `\u003e\u003e\u003e not None` displays `True` because `None` is a falsey value\n- `\u003e\u003e\u003e True and 0` displays `0` (because last evaluated expression is `0`?)\n- `\u003e\u003e\u003e 0 or False or 2 or 1/0` displays `2` because `2` is the expression that makes the statement be true\n- I think that what gets printed by the interpreter is the last evaluated value that makes the expression be true or false!\n- use `python3 ok -q [\"question\"] -i` to open an interactive terminal for the question\n- use `python3 ok -q [\"question\"] --trace` to look at an environment diagram for the question\n\n### lab 02: higher-order functions, lambda expressions\n\n- transforming a function `f(x,y)` into `g(x)(y)` is known as currying\n    ```python\n    def lambda_curry2(func):\n        return lambda x: lambda y: func(x,y)\n    ```\n    \n- sometimes, trying to refer to a variable in the parent frame won‚Äôt work ‚Äî use the `nonlocal` keyword to reframe the variable\n    - idk why it doesn‚Äôt work\n- Church numerals‚Ä¶\n\n### disc 02: higher-order functions, self reference\n\n- a lambda expression doesn‚Äôt return anything until the lambda is called\n- the parent of any function is the frame where the function is defined ‚Äî variables can be included in the parent frame, which can also be accessed in the function‚Äôs frame (sometimes use `nonlocal`)\n- self-reference is when a function *returns* itself, but doesn‚Äôt *call* itself\n\n### disc 03: recursion\n\n- three parts to a recursive function\n    - **base case**: the stopping condition, the simplest case, ex: $0! = 1$\n    - **recurse onto smaller problems**: to recursively call on a simpler problem than the current one and breaking it into parts\n    - **solve the big problem in parts**: since we can solve many small parts, use that to solve the bigger parts\n\n### hog\n\n- `*args` is a parameter will take a bunch of arguments and pass them all as a group\n\n### lab 04: recursion, tree recursion, python lists\n\n- if/else can be done in a list comprehension ‚Äî just an ordering issue\n    ```python\n    [ [true action] if [condition] else [false action] for x in [sequence] ]\n    ```\n    \n- ternary statements in python\n    ```python\n    value_if_true if condition else value_if_false\n    ```\n    \n\n### disc 04: tree recursion, python lists\n\n- tree recursion is used for problems where there can be multiple possibilities to deal with, such as Fibonacci numbers needing to calculate `n-1` and `n-2`\n- recursive calls are made for a group of choices\n\n### disc 05: trees, data abstraction, sequences\n\n- **constructors** build abstract data type ‚Äî also called constructors in Java?\n- **selectors** retrieve information from a data type ‚Äî probably getters\n- tree language:\n    - **parent node**: a node that has at least one branch (child)\n    - **child node:** node with a parent\n    - **root:** the top node\n    - **label:** the value at a node\n    - **leaf:** a node with no children (branches)\n    - **depth:** how far the node is from the root\n    - **height:** the depth of the lowest leaf\n\n### disc 08: linked lists, trees\n\n- unpack a list of elements into a `zip` function by adding `*` before the list\n    - `zip(*[[1,2],[3,4],[5,6]])`\n\n### lab 10: scheme\n\n- `(or 1 #t)` evaluates to `1`\n\n### hw 07:\n\n- `(let ((bindings)) (body))`\n    - SchemeError: badly formed expression:\n        - probably missed the extra parentheses around the bindings\n\n---\n\n### unfinished/review q‚Äôs\n\n- hw01: review `quine`\n- hog: finish problem 12\n- hw02: finish `church numerals`\n- hw03: finish `towers of hanoi`; review `anonymous factorial`\n- disc04: finish `max product`\n- disc06: finish `mystery reverse environment diagram`\n- hw06 `VirFib` `is_bst`\n- disc08: `Multiply Links` `Find Paths`\n- ants: EC, optional 1 \u0026 2","lastmodified":"2023-08-24T05:02:02.331071971Z","tags":[]},"/private/fa22/cs252":{"title":"CS 252","content":"\u003e The computer is not an electronic genius; on the contrary, if anything, it is an electronic idiot, doing exactly what we tell it to do. It has no mind of its own.\n\n# lectures\n## intro\n- Main components of the computer:\n\t- Processor - CPU; memory - RAM; motherboard; GPU; cooling; power supply\n\t- Storage -- SSD, HDD, thumbdrives, hard drives\n\t\t- Remembers things after the power is turned off\n\t- Output devices -- displays, sound\n\t- Input devices -- keyboard, mice, touch\n- CPU components:\n\t- Bus memory; control unit; memory (cache, register); ALU FPU; clock\n\n# reading\n## ch2: bits, data types, and operations\n-   Devices inside the computer react to the presence/absence* of voltages, rather than the actual voltage values\n    -   Presence of voltage is represented as 1, while absence is represented as 0 ‚Äî these 1s and 0s are called **bits**\n    -   *Not the absolute presence/absence, but differentiate between ‚Äúclose to‚Äù and ‚Äúfar from‚Äù a target voltage, ex: if I wanted 3 volts, then 2.6 volts would signify a 1 (close to 3 volts) and 0.2 volts would signify a 0 (far from 3 volts)\n-   With $k$ bits, we can distinguish at most $2^k$ different values, by counting in binary\n-   Unsigned (and signed) integers can be represented using the **2‚Äôs complement integers**\n    -   Each digit in a binary string represents 2 to the power of that digit multiplied by 0 or 1\n        $00110 = 0\\cdot2^4+0\\cdot2^3+1\\cdot2^2+1\\cdot2^1+0\\cdot2^0=6$\n-   For signed integers, the leading value (on the left) signifies positive or negative ‚Äî leading 0 is positive, leading 1 is negative\n\t- ![[Pasted image 20220911015108.png]]\n    -   $k$ bits can represent the range $[-2^{k-1}, 2^{k-1})$ where negative numbers are denoted by a leading 1\n        -   Shortcut for $-A(A\\ne0)$: flip all bits of $A$ and add 1\n    -   The carry for the leading digit is always ignored (because adding 00001 and 11111 does not make sense to produce 100000 when working with signed digits)\n- **Arithmetic and logic unit (ALU)** takes two inputs and one output to apply arithmetic\n- To convert from binary to decimal, we can multiply the $i$th bit (from the right) of the 2's complement number by $2^i$ and add a negative sign if the leading digit is 1\n- Algorithm for converting from decimal to binary:\n\t- *If $N$ is odd, the rightmost bit is 1. If $N$ is even, the rightmost bit is 0.\n\t- Subtract 1 or 0 depending on if $N$ is even or odd, and divide by 2, adding 1 or 0 depending on even/odd\n\t- Example:\n\t\t```text\n\t\t[ converting 105 to binary ]\n\t\tN = 105       : 1 (rightmost bit is 1 because N is odd)\n\t\t  = 105-1     :   (subtract 1 because N is odd)\n\t\t  = 104/2     :   (divide by 2)\n\t\tN = 52        : 01 (next bit is 0 because N is even)\n\t\t  = 52-0      :    (N is even)\n\t\t  = 52/2      :    (divide by 2)\n\t\tN = 26        : 001 (next bit is 0)\n\t\t  = (26-0)/2  : \n\t\tN = 13        : 1001 (next bit is 1)\n\t\t  = (13-1)/2  :\n\t\tN = 6         : 01001\n\t\t  = (6-0)/2   :\n\t\tN = 3         : 101001\n\t\t  = (3-1)/2   : \n\t\tN = 1         : 1101001\n\t\t```\n- Addition with bits remains the same as normal arithmetic, but subtraction is \"adding the negative number\"\n\t- Two numbers must have the same number of bits to be added\n\t- Leading 0s (or 1s for negative numbers) can be added to the front of the number to achieve equal numbers of bits -- this process is called **Sign-EXTension, or SEXT**\n- **Overflow** happens when the ALU can't represent arithmetic between two integers\n\t- Example: I want to add $01001$ (11) and $01011$ (9) but I get $10100$ which is -4 (leading 1 means negative)\n\t- Example: Adding $10100$ (-6) and $11010$ (-12) gets $01110$ which is 14\n- **Logical functions** can also be applied on binary numbers, requiring two pieces of input (either 1 or 0)\n\t- **AND:** produces 1 only if both sources have value 1, otherwise produces 0 (if both are true -\u003e true, else false)\n\t- **OR:** produces 0 only if both sources have value 0, otherwise produces 1 (if either is true -\u003e true, else false)\n\t- **NOT:** flip the bit\n\t- **XOR:** exclusive-or, produces 1 only if *one or the other* input bit is 1, but produces 0 when both inputs are 1\n\t-\n\t\t| A  | B | XOR |\n\t\t| --- | --- | --- |\n\t\t| 0 | 0 | 0 |\n\t\t| 0 | 1 | 1 |\n\t\t| 1 | 0 | 1|\n\t\t| 1 | 1 | 0|\n- **Bit vectors** can keep track of the \"status\" $n$ units where a bit is 1 if the unit is free and 0 if the unit is busy\n\t- **Bit masks** can be used to change the status of one single bit\n- Floating point data is used to represent really big or small numbers with scientific notation (ex: $6.032\\times 10^{23}$ instead of $603200000000000000000000$)\n\t- ![[Pasted image 20220911103146.png]]\n\t- 8 bits are allocated to the \"exponent\" while 23 bits are allocated to the sig figs (the 6032 in the previous example)\n\t\t- The exponent value actually represents your exponent value plus 127 (??)\n\t- Example:\n\t```text\n\tfloating point data: 00111101100000000000000000000000\n\t\t\n\t0 01111011 00000000000000000000000\n\t0 - represents positive number\n\t01111011 - equals 123, subtract 127, we get -4 as the exponent\n\t00000000000000000000000 - no fraction, so the number represented is 1\n\n\t1^(-4) = 1/16\n\t```\n- Other common data codes/notations: ASCII, hexadecimal\n\n## digital logic structures\n\n","lastmodified":"2023-08-24T05:02:02.363072087Z","tags":[]},"/private/fa22/cs475":{"title":"CS 475","content":"## permutations and combinations\n- $|S|$ denotes the number of elements in $S$, cardinality/size of $S$\n- **Addition Principle:** $|S| = |S_1| + |S_2| + \\dots + |S_n|$\n\t- $S$ is partitioned such that each element within $S$ shows exactly once within any one partition, no overlapping elements\n\t- Summing all partitions should always equal $|S|$\n- **Multiplication Principle:** $|T_1\\times T_2\\times \\dots T_k|=|T_1|\\times|T_2|\\times\\dots |T_k|$\n\t- The *Cartesian product* of two sets is the set of $A \\times B$ with ordered pairs $(a, b)$ where $a$ is from $A$ and $b$ is from $B$ -- $\\{(a,b) | a\\in A, b\\in B\\}$\n- n-stage experiment describes how many subsets can be constructed from a set (?)\n- If one of your tasks \"depends\" on the choice of another task, then we can't apply the multiplication principle. Ex: if choosing the tens digit of a number *depends* on if the ones digit is odd, then we can't calculate the answer by getting the tens digit first. (describe better example)\n- **Subtraction Principle:** $|A|=|U|-|\\bar A|$\n\t- Given two sets, $A$ and $U$, where $A \\subseteq U$, the complement of $A$ in $U$ is all the elements in $U$ that are not in $A$ -- $\\bar A=U-A=\\{x|x\\in U,x\\notin A\\}$\n- **Division Principle:** $\\text{number of subsets}=\\frac{|S|}{\\text{the cardinality of each subset}}$\n\t- We partition $|S|$ into subsets of equal size and want to figure out how many *distinct* arrangements exist\n\t- \\*Divide total number of combinations by the size of each group\n- A **permutation** is an ordered arrangement of elements without repetition\n\t- An $r$-permutation is an ordered arrangement of $r$ elements where $r$ is a number\n- $n!=n(n-1)(n-2)\\cdot\\dots\\cdot(2)(1)$ where $0!=1$; product of $n$ and all integers less than $n$\n- $P(n,r)=\\frac{n!}{(n-r)!}$ for positive integers $n$ and $r$ ***REVIEW***\n\t- $P(n,r)$ represents the number of $r$-permutations of an $n$ element \n\t- Special cases: $P(n,1)=n$, $P(n,n)=n!$\n\n---\n- Main types of counting problems:\n\t- Ordered arrangements without repetition\n\t- Ordered arrangements with repetition\n\t- Unordered arrangements without repetition\n\t- Unordered arrangements with repetition\n- Nonrepetition and repetition can also be seen as items from a set (distinct members) and items from a multiset (not distinct members)\n\t- A multiset is denoted by a number before each element of the set, meaning how many of that element is present, ex: $\\{3\\cdot a, 1\\cdot b,2\\cdot c, 4\\cdot d\\}$\n- The multiplication principle cannot be applied if one outcome depends on a previous outcome -- but there may not be a fixed order that tasks need to be completed in, so try rearranging the tasks so that multiplication is applicable -- choose the most restrictive choice first\n- Arrangements where order is considered are called **permutations**, while arrangements where order is irrelevant are called **combinations**\n- $r$ is a positive integer and the number of $r$-permutation of $n$ elements can be denoted by $P(n,r)$\n\t- $S=\\{a,b,c\\}$, so $1$-permutations would be $a$, $b$, $c$; $2$-permutations would be $ab$, $ac$, $bc$, $ba$, $ca$, $cb$; etc\n\t- $P(n,r)=\\frac{n!}{(n-r)!}$\n- **Linear permutations** are permutations where objects are arranged in a line\n- **Circular permutations** arrange objects in a circle -- a permutation is only different if each element has different adjacent neighbors from previous permutations and it cannot be achieved through rotation\n\t- The number of circular permutations of $n$ elements is $(n-1)!$\n\t","lastmodified":"2023-08-24T05:02:02.363072087Z","tags":[]},"/private/fa22/ece537":{"title":"ECE 537","content":"## introduction to networks\n- Internet -- network of networks\n- Computer network structure can look like this: end device (phone) -\u003e router -\u003e Internet Service Provider (ISP) -\u003e ?? -\u003e server\n\t- Router can be wifi router or a cellular provider\n\t\t- Redirects connection on where to go next ...\n\t- ISP connect determines how good router connection is (and also your phone to the router)\n- Any ~~link~~ connection between two devices can be wireless\n- **TCP/IP protocol stack:** physical \u003e link \u003e network \u003e transport \u003e application\n\t- (Transmission Control Protocol/Internet Protocol)\n\t- An *application* level protocol could look like this: client (browser tab) -\u003e ISP -\u003e backbone/hall network (?) -\u003e server\n\t\t- Nothing between client and server actually understand the information transferred -- this means applications are End-to-End protocol, only the end devices understand what's going on\n\t- Physical (layers) need *everyone* to understand the content that passes through (I think it's less private?)\n\t\u003c!-- - Transport takes one layer to another?? probably e2e protocol --\u003e\n\t- Network has protocols that define many stops/nodes (such as ISP, servers) but each stop/node only knows its own predecessor and successor, known as **routing layers**\n\t\t- Each node only cares about getting to the next node and doesn't affect other information being transferred\n\t\t- Network protocol is lower level than application/transport, so any changes on those protocols won't affect network protocol efficiency\n\t- Link layer protocol manages multiple devices talking to one service/router\n\t\t- No protocols with only link layer! always linked to physical \n\t\t- Wifi/ethernet is link and physical\n- Transport/application only need to be understood by end devices; link and physical protocol need to be understood by *all devices in the network*\n- **OSI protocol stack:** physical \u003e link \u003e network \u003e transport \u003e session \u003e presentation \u003e application (industry standard)\n\n## network architecture\n- Networks transfer chunks of information called **packets**\n\t- Data deconstruction (creating packets) is handled by the client, while data reconstruction/packet synthesizing is handled by whoever is receiving the data\n- Two main types of network systems:\n\t- **Circuit switched network:**\n\t\t- A connection of a certain mbps is dedicated to the user for the entire duration of the information transfer\n\t\t- Pros:\n\t\t\t- Connection does not delay or break because it's allocated already\n\t\t\t- You are guaranteed whatever connection speed the whole time\n\t\t\t- Less inturruption -\u003e reliable\n\t\t- Cons:\n\t\t\t- Expansion requires exponentially more resources so it's not scalable\n\t\t\t- Resource is not allocated based on need\n\t- **Packet switched network:**\n\t\t- Information is broken into packets/segments which are transferred individually and only use the connection when a transfer is in progress\n\t\t- Pros:\n\t\t\t- Network is easy to expand -- add more nodes (routers) that can accept and redirect incoming information\n\t\t\t- More people can use the same amount of resources since any downtime between a conversation can be put towards transferring someone else's data\n\t\t- Cons:\n\t\t\t- Packets can arrive out of order which cause delays\n\t\t\t- Networks can be overloaded or slow depending on usage\n- Four main types of *delays*:\n\t- **Processing delay:** \n\t\t- Time it takes to process the packet (add a header?) and find the next location to send it to\n\t\t\t- Does NOT depend on packet size -- all packets take the same time to get ready (I assume?)\n\t\t- Depends solely on the hardware and processing power of the router\n\t- **Propagation delay:**\n\t\t- Time it takes for the packet to *physically* travel through a medium (fiber optic cables, waves, wireless) to its destination\n\t\t- Depends on the distance between two nodes and the speed of the transport medium\n\t- **Transmission delay:**\n\t\t\n","lastmodified":"2023-08-24T05:02:02.363072087Z","tags":[]},"/private/fa22/mse299":{"title":"mse299","content":"","lastmodified":"2023-08-24T05:02:02.363072087Z","tags":[]},"/private/fa22/physics201":{"title":"PHYSICS 201","content":"\u003c!-- # review\n\n-   The SOH-CAH-TOA trig identities only work for right triangles\n-   For finding sides and angles of general (non right) triangles:\n    -   **Law of sines**: $\\frac{\\sin{A}}{a}=\\frac{\\sin{B}}{b}=\\frac{\\sin{C}}{c}$ where the sine of an angle is divided by the length of its opposite side ‚Äî should only be used if you know the angle will be acute or obtuse since it only returns values [0,90]\n    -   **Law of cosines**: $a^2 = b^2+c^2-(2bc)*\\cos{A}$\n-   The quotient rule for derivatives: $\\frac{d}{dx}(\\frac{f(x)}{g(x)})=\\frac{g(x)f'(x) - f(x)g'(x)}{(g(x))^2}$, or ‚Äúlow d hi _mine_ hi d low, _o_ low low‚Äù\n-   **Scalars** are values with a single number, like speed, height, temperature, while **vectors** have a magnitude and a direction, like acceleration, weight\n-   Vector operations:\n    -   Addition: $\\vec{A}+\\vec{B}=\\vec{B}+\\vec{A}=\\vec{R}$\n    -   Scalar multiplication: $s(\\vec{A}+\\vec{B})=s(\\vec{A})+s(\\vec{B})$\n-   A **unit vector** always has magnitude 1\n    -   $\\vec{v}=|\\vec{v}|\\hat{v}$ where $|\\vec{v}|$ is the magnitude of $v$ and $\\hat{v}$ is the unit vector\n    -   $x$ direction unit vector is $\\hat{i}$; $y$ direction is $\\hat{j}$; $z$ direction is $\\hat{k}$\n        -   $\\vec{V}=a\\hat{i}+b\\hat{j}+c\\hat{k}$\n-   Unit vector formula: $\\hat{u}_v=\\frac{\\vec{v}}{|\\vec{v}|}$\n    -   Magnitude formula: $|\\vec{v}|=\\sqrt{|\\vec{v}^x|^2+|\\vec{v}_y|^2+|\\vec{v}_z|^2}$\n-   **Dot product**: $\\vec{A}\\cdot\\vec{B}=|\\vec{A}||\\vec{B}|\\cos(\\theta)$; produces scalar product of two vectors\n    -   Commutative property holds; associate property only holds for scalar mult.; distributive property holds onto for vector addition\n-   **Cross product**: $\\vec{A}\\times\\vec{B}=|\\vec{A}||\\vec{B}|\\sin(\\theta)\\hat{n}$; produces vector product of two vectors\n    -   Not commutative; associative only for scalar mult.; distributive only for vector addition\n    -   Can be evaluated by taking the determinant of a 3x3 matrix\n-   The **right hand rule** is used to determine the direction of the norm vector $\\hat{n}$ of a cross product\n\n![right hand rule](/images/physics201/right-hand-rule.png)\n\n-   A **position vector** describes the location of a particle relative to a reference point at time $t$\n-   A **displacement vector** is the change in the position of a particle between two distinct time periods\n-   **Average velocity** is the change in displacement divided by the change in time $\\vec{v}_{avg}=\\frac{\\Delta\\vec{r}}{\\Delta t}$ while the **velocity vector** is the velocity of a particle at a moment in time $\\vec{v}(t)=\\frac{d\\vec{r}(t)}{dt}$\n    -   The speed (scalar) of the particle is the magnitude of the velocity at that moment\n-   The **acceleration vector** is the second derivative of the position vector $\\vec{a}(t)=\\frac{d\\vec{v}(t)}{dt}$\n-   Constant acceleration can be assumed for most many scenarios (like projectile motion) and the following three equations can be used:\n    -   $v=v_0+a_c(t-t_0)$\n    -   $s = s_0+v_0(t-t_0)+\\frac{1}{2}a_c(t-t_0)^2$\n    -   $v^2=v_0^2+2a_c(s-s_0)$\n-   **Projectile motion** is the motion of a particle moving through the air, while **free fall** is straight line motion with zero initial velocity\n-   Horizontal and vertical motion are independent of each other\n-   Equations relating components of a vector:\n    -   $v^2 = v_x^2+v_y^2$\n    -   $v_{0x}=v_x\\cos\\theta$; $v_{y0}=v_0\\sin\\theta$\n-   **Newton‚Äôs Laws of Motion**\n    -   **First**: A body remains at rest or remains in motion in the absence of applied forces ‚Äî if there is zero net force, then object remains in constant velocity\n    -   **Second**: $\\vec{F}=m\\vec{a}$\n    -   **Third**: The forces of action and reaction between particles are equal in magnitude, opposite in direction, and collinear\n-   **Normal force** is the force which prevents an object from moving through a surface (like a floor)\n-   **Friction** is the portion of contact force between two surfaces, tangent to the contact surface ‚Äî it is always opposing relative motion between contacting objects\n    -   $F=$ friction force; $\\mu_s=$ static coefficient of friction; $N=$ normal force; $\\mu_k =$ kinetic coefficient of friction\n    -   No slip: $|F|\u003c\\mu_s|N|$ ‚Äî the objects are not moving or sliding against each other; friction cannot be calculated based on $\\mu$ and $N$, but could be calculated from $\\vec{F}=m\\vec{a}$\n    -   Impending slip: $|F|=\\mu_s|N|$ ‚Äî one object is just about to slide against the other\n    -   Slip: $|F|=\\mu_k|N|$ ‚Äî they are sliding\n\n--- --\u003e\n\n# lectures\n## course intro \u0026 measurement\n- The final figure is the \"estimated\" figure -- keep all sure digits and one estimated digit\n- Don't count leading zeroes when counting sig figs, but include tailing zeroes\n- Keep all digits until calculations are finished and round after\n\t- Addition/subtraction: the last significant figure after the decimal point can't be more accurate than any of the operands, meaning the # of sig figs (after decimal) is the same as the lowest out of the operands\n\t- Multiplication/division: lowest # of sigfigs among all operands, note that it's NUMBER of sigfigs which is different than after the decimal point\n\n# reading\n## ch1: physics and measurement\n- **SI** system of measurement:\n\t- **Length (meters)** as the distance between two points\n\t- **Mass (kilograms)** as an object's amount of material...\n\t- **Time (seconds)**\n- **Density ($\\rho$):** $\\rho\\equiv\\frac{m}{V}$; mass per unit volume\n- Sometimes we want to express really small numbers, which we can do so using scientific notation and *order of magnitude*, where the ~ symbol denotes \"is on the order of\", ex: 720m ~ (is about) 10^3m\n\n## ch2: motion in one dimension\n-   **Position ($x$):** location of the particle with respect to an origin point\n-   **Displacement ($\\Delta x)$:** $\\Delta x\\equiv x_f-x_i$; change in _position_ over a time interval\n    -   **Average velocity (m/s):** $v_{x,avg}\\equiv\\frac{\\Delta x}{\\Delta t}$; _displacement_ per time interval\n    -   **Instantaneous velocity (m/s): $v_x\\equiv\\frac{dx}{dt}$**; _velocity_ at a moment in time\n-   **Distance:** length of a path travelled by a particle ‚Äî different than _displacement_\n    -   Displacement can be zero even if distance is not zero, ex: moving down a hallway and then returning to the starting position has a displacement of 0, but a distance of the length of the hallway travelled * 2\n    -   **Average speed (m/s):** $v_{avg}\\equiv\\frac{d}{\\Delta t}$; _distance_ per time interval\n    -   **Instantaneous speed (m/s):** magnitude of _instantaneous velocity_\n-   **Vector:** direction and magnitude; **Scalar:** numerical value and no direction\n-   A particle can have a constant velocity, which implies that it has a constant speed; however, constant speed does not imply constant velocity (magnitude can stay the same, but direction doesn‚Äôt always)\n-   Problem solving approach: conceptualize, categorize/simplify, analyze, finalize\n- **Average acceleration ($a_{x,avg}=\\frac{\\Delta v_x}{\\Delta t}$):** measured in $\\frac{m}{s^2}$ and describes the change in velocity over time\n\t- **Instantaneous acceleration ($a_x=\\frac{dv_x}{dt}=\\frac{d^2x}{dt^2}$):**\n\t- Kinematics equations assumed to be true under constant acceleration:\n\t\t- $v_{xf}=v_{xi}+a_xt$\n\t\t- $x_f=x_i+\\frac{1}{2}(v_{xi}+v_{xf})t$\n\t\t- $x_f=x_i+v_{xi}t+\\frac{1}{2}a_xt^2$\n\t\t- $v_{xf}^2=v_{xi}^2+2a_x(x_f-x_i)$\n- If acceleration and velocity have the same sign, that means the particle is speeding up; if they have different signs, the particle is slowing down\n- A freely falling object is any object moving solely under the influence of gravity\n\t- Acceleration due to gravity, or **free-fall acceleration**, is denoted with $g$, and is about $9.8 \\frac{m}{s^2}$\n\n## ch3: vectors\n- Cartesian coordinates, also called rectangular coordinates, are expressed as $(x, y)$\n- Polar coordinates are measured in distance from the origin, and angle from the positive right axis -- $(r, \\theta)$\n- **Scalars** consist of a single value with a unit but without a direction; **vectors** have number, unit (magnitude), and direction\n\t- Vectors are comprised of *components*, which are the $x$ and $y$ vectors that make up the vector -- $A_x=A\\cos\\theta$, $A_y=A\\sin\\theta$\n- A **unit vector** is a dimensionless vector that has a magnitude of 1 -- it only specifies 1 unit of distance in a direction\n\t- Common unit vectors include $\\hat{i}$, $\\hat{j}$, $\\hat{k}$ for one unit in the $x$, $y$, and $z$ directions respectively\n\t- Vectors can be added by adding their components together\n- Vectors can be added by using the head-to-tail method of placing the tail of a new vector at the tip of the last vector\n- ![[Pasted image 20220911112820.png]]\n\t- Addition is commutative and associative\n\t- Subtraction is adding a negative vector -- invert both the direction and magnitude of a vector to get its negative version\n- Scalar multiplication for vectors consists of multiplying the magnitude by a scalar value\n\n## ch4: motion in two dimensions\n- **Position vector ($\\vec{r}$):** $\\vec{r}=x\\vec{i}+y\\vec{j}$;  location of the particle with respect to the origin of a coordinate system\n- **Displacement vector ($\\Delta \\vec{r}$):** $\\Delta \\vec{r}\\equiv\\vec{r}_f-\\vec{r}_i$; a vector that describes the change in position vectors\n\t- **Average velocity:** $\\vec{v}_{avg}\\equiv\\frac{\\Delta\\vec{r}}{\\Delta t}$; displacement vector per time interval, or how much the displacement changes for every $t$ -- results in a vector along $\\Delta\\vec{r}$\n\t- **Instantaneous velocity:** $\\vec{v}\\equiv\\frac{d\\vec{r}}{dt}$; velocity vector at a moment in time, tangent to the particle's path\n\t\t- Speed ($|\\vec{v}|$) of the particle is the magnitude of the *instantaneous velocity*\n- **Average acceleration ($\\vec{a}_{avg}\\equiv\\frac{\\Delta\\vec{v}}{\\Delta t}$)** and **instantaneous acceleration ($\\vec{a}\\equiv\\frac{d\\vec{v}}{dt}$)** describe the change in velocity per $t$ and as $t$ approaches 0 respectively\n\t- Under constant accerlation, we can assume the following equations: (Search \"four kinematics equations\")\n\t\t- $\\vec{v}_f=\\vec{v}_i+\\vec{a}t$\n\t\t- $\\vec{r}_f=\\vec{r}_i+\\vec{v}_it+\\frac{1}{2}\\vec{a}t^2$\n\t\t- $\\vec{r}_f=\\vec{r}_i+\\frac{1}{2}(\\vec{v}_i+\\vec{v}_f)t$\n\t\t- $\\vec{v}_f^2=\\vec{v}_i^2-2\\vec{a}\\Delta\\vec{r}$\n\t\t![constant acceleration equations](/images/physics201/constant-acceleration-eqns.png)\n - Movement in the $x$ direction does not affect movement in the $y$ direction -- motion in 2d can be modelled as two independent motions\n - **Projectile motion** is parabolic motion through the air where we assume free-fall acceleration is constant and air resistance is negligible\n - One specific case of projectile motion is when it returns to the same horizontal level as when it starts\n![projectile motion](/images/physics201/projectile-motion.png)\n\t - $h$ is the maximum height ($h=\\frac{v_i^2\\sin^2\\theta_i}{2g}$), while $R$ is the horizontal range of the particle ($R=\\frac{v_i^2\\sin2\\theta_i}{g}$)\n\t\t - $R$ is at its maximum when $\\theta$ is 45 degrees\n\t\t ![different ranges at various angles](/images/physics201/angle-example.png)\n- Uniform circular motion describes when a particle is moving in a circular motion at a constant speed\n\t- The direction of the velocity vector is always changing in circular motion, so an acceleration is present and points towards the center of the circle, perpendicular to the velocity vector\n- Acceleration in circular movement is defined by $a_c=\\frac{v^2}{r}$, $a_c=r\\omega^2$, also called **centripetal acceleration**\n\t- The length of time it takes to complete one circle of rotation is called the **period** $T$ -- $T=\\frac{2\\pi r}{v}$\n\t- **Angular speed** $\\omega$ is measured in radians/second and is the inverse of $T$ -- $\\omega=\\frac{2\\pi}{T}$\n\t- $v=r\\omega$: as radial position increases (away from the center), speed also increases","lastmodified":"2023-08-24T05:02:02.363072087Z","tags":[]},"/projects":{"title":"Projects","content":"- [Network analysis](/ece537): Observing wireless network behavior on campus\n- Summer Exploration Arc (SEA): Progress tracking during summer break\n    - 2022: [#1](/2022-sea1), [#2](/2022-sea2), [#3](/2022-sea3)\n","lastmodified":"2023-08-24T05:02:02.363072087Z","tags":[]},"/shortcuts":{"title":"coding shortcuts","content":"\n```python {title=\"list comprehensions are the bane of my existence\", linenos=false}\nnums = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n# operation on each item\n[x+1 for x in nums]\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n\n# using IF\n[x for x in nums if x%2==0]\n[0, 2, 4, 6, 8, 10]\n\n# using IF + ELSE \n[x if x%2==0 else \":(\" for x in nums]\n[0, ':(', 2, ':(', 4, ':(', 6, ':(', 8, ':(', 10]\n\n# stacking IFs?\n[x for x in nums if x if x%2==0 if x%3==0]\n[6]\n[x for x in nums if x if x%2==0 and x%3==0]\n[6]\n\n```\n\u0026nbsp;\n\n```python {title=\"zipped lists\", linenos=false}\nfor (a, b) in zip(list_a, list_b)\n```\n\u0026nbsp;\n\n```python {title=\"Series: max min\", linenos=false}\ns = Series\n\ns.idxmin() # index of the min value\ns.idxmax() # index of the max value\ns.min() # min value\ns.max() # max value\n```\n\u0026nbsp;\n\n```python {title=\"Series: iloc, index, name\", linenos=false}\n###\nArgentina    690.784168\nName: Chile, dtype: object\n###\n\ndf.iloc[0]  # returns 690.784168 -- \"integer location 0\"\ndf.index[0] # returns Argentina -- index(key) at location 0\ndf.name     # returns Chile\n```\n\u0026nbsp;\n\n```python {title=\"copy + modify every leaf in a tree\", linenos=false}\nif is_leaf(t):\n        # return new leaf \n    else:\n        new_branches = []\n        for branch in branches(t):\n            new_branches.append(\u003crecursive call\u003e)\n        return tree(label(t), new_branches)\n```\n","lastmodified":"2023-08-24T05:02:02.459072435Z","tags":[]},"/utm-ubuntu":{"title":"Ubuntu 22.04 with UTM","content":"- No easy way to dual boot with the M1 chips -- UTM is a software specifically for macOS to run VMs or emulate other machines\n- How to create a new Ubuntu VM:\n    - Install the 22.04 live server arm64 ISO image\n    - Start \u003e Virtualize \u003e Other and select the ISO image\n    - Create a new NVMe drive for 20GB\n    - Go through Ubuntu setup\n- Installing GNOME desktop environment\n    - `sudo apt update \u0026\u0026 sudo apt upgrade`\n    - `sudo apt install ubuntu-gnome-desktop`\n    - `reboot`\n\nArticles that I used:\n- https://bytexd.com/how-to-install-gnome-desktop-in-ubuntu/\n- the beginning of this video https://youtu.be/GjqeoC267FM\n- the middle of this video https://youtu.be/hnwK-nkXolc\n\nUpdated 7/23: You can run an Ubuntu VM using Xcode with [this](https://developer.apple.com/documentation/virtualization/creating_and_running_a_linux_virtual_machine) tutorial ","lastmodified":"2023-08-24T05:02:02.459072435Z","tags":[]}}
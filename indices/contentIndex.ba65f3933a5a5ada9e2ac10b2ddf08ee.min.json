{"/":{"title":"emilyyao.me","content":"\n# hey, it's squeak!\nWelcome to my pothole of the internet. I'm Emily! My nickname is \"*squeak*\" ‚Äî from which most of my usernames on the web are derived. I'm currently a first-year at UW-Madison studying CS/CompE. I'm primarily interested in robotics and machine learning, and applying these skills in a competition format. In my free time, I love reading historical fiction and listening to [copyrighted Nintendo music](https://youtu.be/HL9_xm5HwrE).\n\nI like meeting interesting people! If you want to say hi or grab lunch some time, send me a message at `hello [at] emilyyao.me`!\n\nIf you're looking for my other website, go to [wiki.emilyyao.me](https://wiki.emilyyao.me/)!\n\n# school\n\n# pages\n- [Notes](/academics.md): [CS 475](/notes/fa22/cs475.md), [ECE 252](/notes/fa22/ece252.md), \n[ECE 537](/notes/fa22/ece537.md), [PHYSICS 201](/notes/fa22/physics201.md)\n- [Posts](/stream.md)\n\n# recent\n- ü•≠ 22-07-16 `::` another [SEA update](/2022-sea3.md) `(sea#3)`\n- üå∞ 22-07-08 `::` [Ubuntu 22.04 using UTM](/utm-ubuntu.md)\n- ü•≠ 22-06-26 `::` [SEA progress update](/2022-sea2.md) `(sea#2)`\n- ü•≠ 22-06-11 `::` [the beginning](/2022-sea1.md) of my summer learning quest `(sea#1)`","lastmodified":"2022-08-28T03:22:22.593483955Z","tags":null},"/2022-sea1":{"title":"Summer Exploration Arc #1","content":"## motivation\nI've always wanted to document my growth over a period of time to see what I can accomplish on my own. This summer is an ideal place to start -- just after high school and before college, where I have enough agency to achieve my goals, without too much academic stress. I'm drawing motivation from this saying: \n\n\u003e Most people overestimate what they can do in a day, but underestimate what they can do in a year.\n\nMy goals are the following:\n- Learn about topics that I think I would enjoy\n- Work on some small projects\n- Build healthy habits\n- Read more, write more\n- Enjoy that summer sun\n\nThey are vague on purpose -- I'll have plenty of options that accomplish these tasks without feeling restricted to a particular path.\n\n## starting point\n### online classes\nBefore the fall semester starts, I want to do a bit of learning on my own. For the most part, I'm going to be reviewing old classes (linear algebra, data structures / algorithms) and exploring new classes (discrete math, artificial intelligence, signals and systems). This is for me to \"test the waters\" and try out things that are interesting to me.\n\n### cool projects\nI'm interested in making something for 3Blue1Brown's [Summer of Math Exposition #2 (SoME2)](https://youtu.be/hZuYICAEN9Y). I'm not particularly sure what knowledge I have to offer but I'm planning on something within the computer science or signal processing realm. \n\nI've also been interested in cybersecurity for the past few months, but never got around to actually learning more about it. Since I have more time now, I want to take advantage of some resources like [HackTheBox](https://hackthebox.com), [OverTheWire: Wargames](https://overthewire.org/wargames/), the [DEF CON CTF archive](https://archive.ooo/) to help me learn more. At the beginning of this year, my goal was to participate in the DEF CON 30 CTF qualifiers, but that has since passed -- my new goal is to take a shot at next year's qualifiers, but we'll see about that...\n\nAmong other things, I want to clean up my website better and get my wiki space set up.\n\n## plan\nMy next update will be in two weeks. For the most part, I want to see where things will take me, so I don't really have a concrete schedule.","lastmodified":"2022-08-28T03:22:22.593483955Z","tags":null},"/2022-sea2":{"title":"Summer Exploration Arc #2","content":"## recap\nI made a [post](/2022-sea1.md) two weeks ago where I wrote about what I wanted to accomplish in my free time this summer. This is my first progress update.\n\nMy focus has primarily been on settling into a good routine where I can balance work and learning in my downtime. I teach summer camps in the morning which has helped me build a solid morning routine. I have plenty of free time in the afternoons, which I've been trying to put towards doing something useful.\n\n## progress\n### academics\nHistorically, I don't have a good track record when it comes to self-paced online courses -- I struggle a lot with finding an interesting yet not-too-difficult class. So far I've tried and dropped Caltech's [Learning From Data](https://work.caltech.edu/telecourse) course because I didn't understand how to do the homeworks -- the answers were in Python, and I don't know Python. I also gave MIT's [18.06SC: Linear Algebra](https://openlearninglibrary.mit.edu/courses/course-v1:OCW+18.06SC+2T2019/about) a shot, but it's moving along very slowly. I think my hesitancy with this class comes from how I'm not confident at writing proofs. While I enjoy Gilbert Strang's lectures, I blank when it comes to applying new concepts on my own.\n\nGoing back to how I don't know Python: it's been on my todo list for a long time. I never got around to actually *learning* Python, and most of my prior experience came from doing beginner [Advent of Code](https://adventofcode.com/) problems. I did find a course that I've been working through [(CS 220 from UW-Madison)](http://msyamkumar.com/cs220/s20/schedule.html) and I'm about 1/3 of the way through. This has been my main focus for the past week as I've settled into this whole summer exploration thing.\n\n### cybersecurity\nLast week I managed to set up Kali Linux on my laptop after a bit of fiddling around. I'm not sure what I intend to do with it -- so far I've just been trying out the [Linux Fundamentals](https://academy.hackthebox.com/course/preview/linux-fundamentals) course on [HTB Academy](https://academy.hackthebox.com/). I want to get more familiar with using terminal and other command line tools. I also plan to finish a cybersecurity certificate I started a long time ago.\n\n### website\nAfter my last post, I spent a while working on my wiki website which is live now at [wiki.emilyyao.me](https://wiki.emilyyao.me). There are still a few things I need to work out (such as the side TOC being wonky on mobile) but it's a good start. I want to use somehow organize my notes and ramblings into comprehensive pages soon. This project will probably take a while until it is presentable. My main goal is to consistently update this during the school year and create something that can help other people, too.\n\n### \"Enjoy that summer sun\"\nI am sunburnt\n\n### misc\n- [my Taiko addiction](https://youtu.be/QbPj5vfprIQ)\n- Current reads: *Homegoing* by Yaa Gyasi; *Normal People* by Sally Rooney\n\n## plan\nMy first goal is to finish the CS 220 course which might take a bit longer than two weeks. I'd also like to finish both of the books I'm currently reading. Other side goals include: finishing the Linux course with HTB, cleaning up my old calculus notes on my wiki, and exiting my house to do something other than drive to work.","lastmodified":"2022-08-28T03:22:22.593483955Z","tags":null},"/2022-sea3":{"title":"Summer Exploration Arc #3","content":"## recap\nThis is the second progress update (third post overall) in the series I started on what I want to accomplish this summer. Read my last post [here](/2022-sea2.md).\n\nLooking at my general goals from last time: I haven't made much progress with Linux nor learned anything cybersecurity related. I did mess around with installing Ubuntu using UTM but I ended up putting it on the backburner. For the most part, I've been working through CS 220.\n\n## progress\n### self-studying\nThis past week I finished [CS 220](/notes/cs220.md)! Learning Python this way has honestly been a joy -- the content at the beginning of the course came naturally since I had some coding experience, and the later topics (web scraping, databases) were fun to mess around with. I think I never had a chance to explore while learning Java because I was more focused on learning *how* to code, like learning syntax rules or what functions were, but now I can actually apply my knowledge. I want to get some more Python experience under my belt first, but my ultimate goal is to give Caltech's [Learning From Data](https://work.caltech.edu/telecourse) another shot.\n\nI was recommended UC Berkeley's [CS 61A](https://inst.eecs.berkeley.edu/~cs61a/fa21/) by a friend, which I've picked up this week. There are three classes in the sequence: 61A, 61B, and 61C -- 61B focuses on Java, which was something that I really wanted to review this summer. This is mostly because I want to compete in some AI programming games, like [Battlecode](https://battlecode.org) or the [Lux AI Challenge](https://lux-ai.org), and I want to brush up on Java before the competitions start.\n\nFinally, I started a discrete math course because I need it for a prerequisite for my actual college classes, and I heard the one at UW-Madison is a disaster. \n\n### reading\nI finished *Normal People* by Sally Rooney. The ending was equal parts dissatisfying, ambiguous, and fitting.\n\n### SoME2\nThe deadline for SoME2 is August 15th, which is in a month. I think I'm going to make something about [Dijkstra's algorithm](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm), which is my favorite algorithm (that I know of). As far as animation and visuals go, I'm only familar with frame-by-frame hand-drawn animation -- I'm going to play around with FlipaClip this week and see how that works out.\n\n### misc\n- Current reads: *Homegoing* by Yaa Gyasi, *At Night All Blood Is Black* by David Diop\n\n## plan\nI'm focusing on balancing my two courses with my work schedule this week. I also want to finish another book and fiddle with my websites some more. Side goals: ICSI certification, break out the tablet and animate a little, and back up my favorite JCS crime videos somewhere.","lastmodified":"2022-08-28T03:22:22.593483955Z","tags":null},"/academics":{"title":"Notes","content":"\n## fall 2022\n- [CS 475: Introduction to Combinatorics](/notes/fa22/cs475.md)\n- [ECE 252: Introduction to Computer Engineering](/notes/fa22/ece252.md)\n- [ECE 537: Communication Networks](/notes/fa22/ece537.md)\n- [PHYSICS 201: General Physics](/notes/fa22/physics201.md)\n\n## summer 2022 (self-studied)\n- [CS 220: Data Programming I](/notes/cs220.md)\n- [CS 61A: Structure and Interpretation of Computer Programs](/notes/cs61a.md) `unfinished`\n- [6.042J: Mathematics for Computer Science](/notes/6-042j.md) `unfinished`","lastmodified":"2022-08-28T03:22:22.593483955Z","tags":null},"/coding-shortcuts":{"title":"coding shortcuts","content":"\n## Python\n\n- find the max and min of a Series\n```python\ns = Series\n\ns.idxmin() # index of the min value\ns.idxmax() # index of the max value\ns.min() # min value\ns.max() # max value\n```\n\n- iloc, index, and name on a Series\n```python\n###\nArgentina    690.784168\nName: Chile, dtype: object\n###\n\ndf.iloc[0]  # returns 690.784168 -- \"integer location 0\"\ndf.index[0] # returns Argentina -- index(key) at location 0\ndf.name     # returns Chile\n```","lastmodified":"2022-08-28T03:22:22.593483955Z","tags":null},"/notes/6-042j":{"title":"6.042J: Mathematics for Computer Science","content":"\n# proofs\n\n## introduction to proofs\n\n- a **proposition** is a statement that is either true or false\n- the $::=$ means ‚Äúequal by definition‚Äù and usually just $=$ is used\n- you can‚Äôt check a claim about an infinite set by checking a finite set of elements\n- symbols\n    - $\\forall$ for all\n    - $\\mathbb{N}$ nonnegative integers\n    - $\\in$ is in, is a member of, belongs to\n    - $\\mathbb{Z}^+$ positive integers\n\n**Proposition.** $313(x^3+y^3)=z^3$ has no solution when $x$, $y$, $z \\in\\mathbb{Z}^+$.\n\nThis latter part can be read as ‚Äúwhen $x$, $y$, $z$ are in the set of all positive integers‚Äù or simpler, there is no solution when $x$, $y$, $z$ are all positive. This proposition is false (but the counterexample has more than 1000 digits.)\n\n- a **predicate** is a proposition whose truth depends on variables and is denoted by [a letter with a function-like notation], ex: ‚Äú$n$ is a perfect square‚Äù depends on the value of the variable $n$\n    - $P(n)::=$ ‚Äú$n$ is the perfect square‚Äù, where we can say $P(4)$ is true and $P(5)$ is false, then $P(n)$ is either true or false.\n- **axioms** are propositions that are simply accepted as true\n- a **proof** is a sequence of logical deductions using axioms and other proved statements\n- other terms for propositions\n    - **theorems** are *important* true propositions\n    - **lemmas** are preliminary propositions useful for proving later propositions\n    - **corollaries** are propositions that [follow in a few logical steps from a theorem] ‚Äî *correlating* to a theorem\n- logical deductions are used to prove new propositions using previously proved propositions\n\n*modus ponens*: a proof of $P$ combined with a proof of $P\\text{ implies }Q$ is equivalent to a proof of $Q$\n\n**Rule.**\n\n$$\n\\frac{P,P\\text{ implies }Q}{Q}\n$$\n\n- statements above the line are proved (called *antecedents*), and statements below the line are called *conclusions*\n- propositions in the form of ‚Äúif $P$, then $Q$‚Äù are called **implications**, and will often be rephrased to $P\\text{ implies }Q$\n    1. write ‚ÄúAssume $P$.‚Äù\n    2. show that $Q$ logically follows\n\n**Theorem.** $\\text{If }0\\le x\\le2\\text{, then }-x^3+4x+1\\gt0.$\n\n*Proof.*\n\n$$\n-x^3+4x=x(2-x)(2+x)\n$$\n$$\nx(2-x)(2+x)+1\\gt 0\n$$\n$$\n-x^3+4x+1\\gt 0\n\\tag*{$\\blacksquare$}\n$$\n\n- proofs begin with the word ‚Äú*Proof*‚Äù and end with ‚ÄúQED‚Äù or $\\blacksquare$\n- a **contrapositive** is when $P\\text{ implies }Q$ is logically equivalent to $\\text{not(}Q\\text{) implies not(}P)$\n    1. write ‚ÄúWe prove the contrapositive:‚Äù\n    2. write ‚ÄúAssume $\\text{not }Q$‚Äù and show that $\\text{not } P$ logically follows\n- a theorem can assert that two statements are logically equivalent, that one holds if and only if the other holds ‚Äî the shortened phrase being $\\text{iff}$\n    - saying that $P\\text{ iff }Q$ is equivalent to saying $P\\text{ implies }Q$ and $Q\\text{ implies }P$\n        1. write ‚ÄúWe prove $P$ implies $Q$ and vice-versa.‚Äù\n        2. show that $P$ implies $Q$ and show that $Q$ implies $P$\n    - $\\text{iff}$s can come in chains\n        1. write ‚ÄúWe construct a chain of if-and-only-if implications.‚Äù\n        2. prove that $P$ is equivalent to a second statement which is equivalent to a third statement and a fourth statement and so forth until $Q$ is reached\n\n---","lastmodified":"2022-08-28T03:22:22.605483999Z","tags":null},"/notes/cs220":{"title":"CS 220: Data Programming I","content":"Self-paced course taken summer '22, linked [here](https://www.msyamkumar.com/cs220/s20/syllabus.html). Introductory data science programming using Python -- teaches Python basics, programming fundamentals, and data science modules in Python. Texts used include Allen B. Downey's *Think Python, 2nd Edition* and Al Sweigart's *Automate the Boring Stuff*. Completed homework linked [here](https://github.com/heyitssqueak/classes/tree/master/cs220).\n\n# control flow\n\n## introduction\n- inputs: keyboard, mouse\n- outputs: monitor, speaker\n- devices attach to the computer via ‚Äúports‚Äù (USB)\n- motherboard: main circuit and connects to other components with sockets and slots\n- CPU, central processing unit\n    - runs code (receives input, sends output)\n    - runs on a clock, measured in Hz (ex. GHz is billions of ticks per second)\n    - high speed CPU ‚Üí hotter\n    - computers have multiple CPUs\n- RAM, random access memory\n    - short term data storage\n        - CPU sends to and from RAM\n    - ‚Äúvolatile‚Äù - lose data when computer is powered off\n    - one byte = one letter\n- storage drives\n    - HDD, hard disk drive\n        - inexpensive, moving parts, slow\n    - SSD, solid state drive\n        - expensive, no moving parts, fast\n    - stores data after computer shut down\n- network: an extension or built-in card to the motherboard\n    - NIC, network interface controller\n        - provides communication to other machines + internet\n    - wired = ethernet, wireless = wifi\n    - server: computer waits for incoming requests which it responds to\n    - client: program that sends requests to a server\n- jupyter notebook runs and displays results of py code without needing to run it yourself\n\n---\n\n## the terminal\n\n- you can connect to terminals located anywhere, such as connecting to a remote computer OR connecting to a personal computer\n- shell helps navigate to program and run\n- helpful shell commands    \n    - `pwd` get working directory ‚Üí current location\n    - `man` opens manual pages for command\n    - `\u003ctab\u003e` autocomplete\n    - `\u003cctrl-C\u003e` kill / exit\n    - `\u003cup arrow\u003e` last used command\n    - `\u003cctrl-R\u003e` search used commands\n    - `cd` open directory\n        - `cd ..` go up a directory\n        - `cd /` go to top directory\n    - `ls` lists contents of current directory\n    - `mkdir` makes new directory\n    - `echo` repeat or copy\n    - `cat` display contents of file\n    - `mv [original] [destination]` move files\n    - `cp [original] [destination]` copy files        \n- pathname: the location of your file (windows: includes drive letter, filename, extension‚Ä¶)\n    - absolute: always possible (complete path name to file)\n    - relative: with respect to current location\n    - working directory: current location\n    - `..` navigates up a directory\n    - `.` navigates into a directory\n- arguments are inputs that come after the call of the program name\n- use `\u003e` to redirect output to a new file\n- use `\u003e\u003e` to add output to a file\n\n---\n\n## programming\n\n- interpreter: a program that translates human-legible code into machine-legible code\n- editor: a program where you can write code\n- jupyter notebook mixes code with other things like images, tables, documentation, etc\n- ways to run python\n    - `python` interactive, denoted by `\u003e\u003e\u003e`\n    - `python [program name]` script\n    - `jupyter notebook` notebook\n- python uses order of operations to simplify equations (parentheses, exponents, m/d, a/s)\n    - negative and positive signs take precedence over m/d\n    - logic operators come after comparison operators which come after math operators\n![operator-diagram](/images/cs220/operator-precedence.png)\n- boolean operators\n    - AND: true when both conditions are true (t/t), false otherwise (t/f, f/t, f/f)\n    - OR: true when one condition is true (t/t, t/f, f/t), false otherwise (f/f)\n    - NOT: true when the condition is false\n        - evaluate: NOT(is it saturday?)\n            - if (is it saturday?) is true, then the expression is false, i.e., it IS saturday\n            - if (is it saturday?) is false, then the expression is true, i.e., it is NOT saturday\n\n### downey ch1: the way of the program\n\n- python uses symbols as *bitwise* operators and words as logic operators\n    - `and` `or` are logic operators\n    - `\u0026` `|` are bitwise operators\n        - convert arguments into binary before comparisons\n- common types: int, float, string, boolean\n- parsing is understanding structure and meaning in a language\n    - formal language: specifically designed languages (like mathematical or molecular notation); means exactly what it says, unambiguous, less redundant/more concise\n    - natural language: naturally-evolved language (like English); has idioms/metaphor, needs redundancy to make up for ambiguity\n\n---\n\n## variables and expressions\n\n- expressions are a mix of operators (logic, mathematical) and operands (values)\n    - an operand *could* be a variable which means it won‚Äôt be a fixed value\n    - `//` is the floor division operator: `x // y` is ‚Äúhow many times does `y` go into `x`?\n- assignments compute an expression and put the result in a variable ‚Äî assignment operator is `=`\n    - ex: `total = x+y` where `total` is the resultant variable; `x` and `y` are operands (and also variables); `x+y` is the expression\n- types of errors\n    - syntax error: the written code is wrong, Python won‚Äôt run, ex: `5 = x`, we can‚Äôt assign `x` to the number `5`\n    - runtime errors: something that crashes when we run the code, ex: `x = 5 / 0`, can‚Äôt divide by zero and will result in a `ZeroDivisionError`\n    - semantic (logic) error: the code runs but you don‚Äôt get the result you want\n- python variable naming conventions\n    - don‚Äôt use keywords\n        |     |     |     |     |     |     |     | \n        | --- | --- | --- | --- | --- | --- | --- |\n        | False | assert | del | for | in | or | while |\n        | None | break | elif | from | is | pass | with |\n        | True | class | else | global | lambda | raise | yield |\n        | and | continue | except | if | nonlocal | return |  |\n        | as | def | finally | import | not | try |  |\n    - don‚Äôt name your variable after a type, like `int` or `str`\n    - only use letters (upper + lower), numbers, underscores\n        - don‚Äôt start the variable name with a number\n    \n    | examples | nonexamples |\n    | --- | --- |\n    | CS220 | 220class |\n    | cs_220 | x! |\n    | _cs220 | pi3.14 |\n\n### downey ch2: variables, expressions and statements\n\n- python conventionally uses lowercase and underscores for variable names\n    - illegal names will cause syntax errors\n- python code can be saved into files called *scripts* which end with `.py`\n- `print()` needs to be used in script mode if you want to display outputs\n- PEMDAS is helpful for remembering the order of operation for expressions\n    - **P**arentheses, **E**xponents, **M**ultiplication and **D**ivision, **A**ddition and **S**ubtraction\n- can‚Äôt perform mathematical operations on strings but we *can* add strings together (called string concatenation)\n    ```python\n    first = 'throat'\n    second = 'warbler'\n    print(first + second)\n    \u003e throatwarbler\n    ```\n- strings can also be multiplied, ex: `'Spam'*3` is `'SpamSpamSpam'`\n- comments are lines that the computer will ignore ‚Äî used to make notes between lines of code for humans to read\n    ```python\n    # compute percentage of an hour\n    percentage = (minute * 100) / 60\n    ```\n    - everything on the line with the `#` symbol is ignored\n    - usually used to denote things that aren‚Äôt obvious to the reader ‚Äî meanings of variables, functions\n- syntax errors appear *before* the program is run; runtime errors appear *after* the program has run; semantic errors don‚Äôt appear at all\n\n---\n\n## using functions\n\n- functions are ‚Äúmini-programs‚Äù or small steps that can build a big program\n- refactoring is when the code is reorganized\n- **parameters** are variables that receive a function‚Äôs input\n- **arguments** are values that are sent to a function\n    - default arguments are values that are sent to the function *if* no custom value is provided\n- **return values** are outputs from the function\n![params-args](/images/cs220/params-and-args.png)\n- calling a function in python: `[fnc name]([arguments])` ex: `print(\"hello\")` where `print` is the function name, followed by parentheses, and `\"hello\"` is the argument\n\n### downey ch3: functions\n\n- **function** - a named sequence that performs a computation\n- python has *modules* which are prewritten code that you can use in your program by importing\n    - ex: functions from the math module can be used after importing it with `import math`, including `math.sin()`, `math.log10(), etc`\n- functions can be called using *dot notation* which is the format `[module name].[function name]`\n- variables are always on the left side of an assignment operator\n\n---\n\n## creating functions\n\n- math to python example\n    $f(x)=x^2$\n    `def f(x):\n        return x ** 2`\n    - both functions are called `f` and take a parameter, `x`, and return the value of `x` squared\n- indentation is important in python!\n    - following the colon after the first line of a function, all following lines are indented 4 spaces\n- filling parameters\n    - positional arguments ‚Äî arguments assigned by position\n        ```python\n        def foo(x, y = -1):\n            x = [] # this would be 99, because 99 is the first arg\n    \t    y = [] # this would be 100\n\n        foo(99, 100)\n        ```\n    - keyword arguments ‚Äî arguments assigned to variable names\n        ```python\n        def foo(x, y = -1):\n            x = [] # this would be 100 because we said x=100 below\n            y = [] # this would be 99\n        \n        foo(y=99, x=100)\n        ```\n    - default arguments ‚Äî inserted arguments if nothing is provided\n        ```python\n        def foo(x, y = -1):\n            x = [] # this would be 99 \n            y = [] # this would be -1 because we specified it above\n        \n        foo(99)\n        ```\n- `return` will provide code to the program that can be used later, while `print()` will output the code to a terminal\n\n### downey ch3 (cont.): functions\n\n- custom functions can be added by using the keyword `def`\n    - the **header** of the function is the first line, while the **body** **(indented 4 spaces) is the rest of the function\n- if the parentheses after the function name are empty, that means the function doesn‚Äôt take any arguments\n    ```python\n    def foo():\n        print(36)\n    \n    foo()\n    \u003e 36\n    ```\n- functions have to be created before they can be called ‚Üí function definitions are always at the top of a program\n    - execution begins at the top of the program and moves down\n- *fruitful functions* return values; *void functions* don‚Äôt return anything\n    - usually want to perform an action with the output of a fruitful function\n\n### reading: creating fruitful functions\n\n- to send a value to a variable instead of printing it to a screen, we can use the `return` keyword ‚Üí is called a fruitful function\n    - result is stored in a variable and can be used again\n    ```python\n    # using print\n    def get_name(first, last):\n        print(first + \" \" + last)\n    \n    name = get_name(\"Jane\", \"Doe\")\n    \u003e \"Jane Doe\"\n    \n    print(name)\n    \u003e None # nothing is assigned to 'name' so it has the None type\n    ```  \n    $\\phantom{-}$\n    ```python\n    # using return\n    def get_name(first, last):\n        return(first + \" \" + last)\n    \n    name = get_name(\"Jane\", \"Doe\") # nothing prints because there is no print statement\n    \n    print(name)\n    \u003e \"Jane Doe\" # the name is returned through the function\n    ```\n- once a `return` statement is reached, the function ends\n    ```python\n    # using print()\n    def countdown_print():\n        print(3)\n        print(2)\n        print(1)\n    \n    countdown_print()\n    \u003e 3\n    \u003e 2\n    \u003e 1\n    ```\n    $\\phantom{-}$\n    ```python\n    # using return\n    def countdown_return():\n        return 3\n        return 2\n        return 1\n    \n    countdown_return()\n    \u003e 3\n    ```\n- `__builtins__` is a special module that is already imported\n- `dir()` lists all functions that are part of a module\n- `.__doc__` returns the documentation of a function\n    ```python\n    import math\n\n    print(math.log.__doc__) # [module name].[function name].__doc__\n    \u003e log(x, [base=math.e])\n    \u003e Return the logarithm of x to the given value\n    ```\n\n---\n\n## function scope\n\n- variable names can be organized in *frames*\n- **frames** are created when a function is called ‚Äî parameters and variables exist in the frame (also called scope?)\n    ```python\n    def print_twice(s): # function frame\n        print(s)\n        print(s)\n    \n    def cat_twice(p1, p2): # different function frame\n        cat = p1 + p2\n        print_twice(cat)\n    \n    line1 = \"bing bong\" # lies in the global frame\n    line2 = \"bong bing\" # lies in the global frame\n    cat_twice(line1, line2)\n    ```\n    - the module can access two variables: `line1` and `line2`\n    - `cat_twice()` accesses three variables: `p1` (which is `line1` passed through the function), `p2` (which is `line2` passed through the function), and `cat`\n    - `print_twice()` only accesses one variable: `s` which is `cat` passed through\n- local variables\n    - functions don‚Äôt execute unless they‚Äôre called\n        ```python\n        def set_x():\n            x = 100\n        \n        print(x)\n        # doesn't print anything because set_x() wasn't called\n        ```\n    - variables created in a function die after the function returns\n        ```python\n        def set_x():\n            x = 100\n        \n        set_x()\n        print(x)\n        # doesn't print because x doesn't exist after the end of the function\n        ```\n    - variables are reset every time a function is called\n    - variables aren‚Äôt shared across functions\n        ```python\n        def display():\n            print(x)\n        \n        def main():\n            x = 100\n            display()\n        \n        main()\n        ```\n        - even though `x` is set to be `100` in the `main()` function, the `display()` function can‚Äôt see the `x` value and it doesn‚Äôt print anything\n- global variables can be used inside functions\n    - python assumes any variables assigned within functions are *local variables*\n        ```python\n        msg = \"hello\"\n        \n        def greeting():\n            msg = \"welcome!\" # local variable, only present within the function\n            print(\"greeting: \" + msg)\n        \n        print(\"before: \" + msg) \n        greeting()\n        print(\"after: \" + msg)\n        \n        \u003e before: hello\n        \u003e greeting: welcome!\n        \u003e after: hello\n        ```\n- use `global [var name]` to declare when to create a global variable\n    ```python\n    msg = \"hello\"\n    \n    def greeting():\n        global msgd\n        msg = \"welcome!\" # local variable, only present within the function\n        print(\"greeting: \" + msg)\n    \n    print(\"before: \" + msg) \n    greeting()\n    print(\"after: \" + msg)\n    \n    \u003e before: hello\n    \u003e greeting: welcome!\n    \u003e after: welcome!\n    ```\n- python arguments are ‚Äúpassed by value‚Äù meaning any change to an argument that happens inside a function does *not* apply to that variable outside of the function\n- the argument and parameter can have the same (or different) name\n\n### downey ch3 (cont.): functions\n\n- inside a function, arguments are assigned to variables called *parameters*\n- variables created inside functions exist only in that function\n- a **traceback** is a list of functions that details what file, line, and functions caused an error\n- usefulness of functions\n    - repetitive code can be named and grouped, which makes debugging easier\n    - reusuable\n- Linux started out as a program that would switch between printing `AAAA` and `BBBB`\n\n---\n\n## conditionals\n- statements are always executed in order, with three exceptions: functions, conditionals, and loops\n- indented lines = ‚Äúinside‚Äù functions\n- questions are often phrased as boolean expressions, while actions are written as statements\n- control flow diagrams are flowcharts for code ‚Äî visual representation of how the code should run\n    ![conditionals](/images/cs220/conditionals.png)\n- a boolean expression uses the `if` keyword and sometimes uses `else` if there are multiple solutions\n    ```python\n    if [boolean expression == True]:\n        # execute code\n    else: # implying that boolean expression == False\n        # execute different code\n    ```\n- *blocks* of code are defined by indentations (which come with colons)\n\n### downey ch4: case study: interface design\n\n- the `turtle` module in python allows you to create images with turtle graphics\n    - basically, it‚Äôs a little ‚Äúturtle‚Äù that you can control using commands (move forward, turn left) to draw stuff\n- `for` loops can be used to repeat pieces of code\n    ```python\n    for i in range(4):\n        print(i + \"hello!\")\n    \n    \u003e 0 hello!\n    \u003e 1 hello!\n    \u003e 2 hello!\n    \u003e 3 hello!\n    ```\n    - the `i` is a counter variable ‚Äî starting at 0, it will increase by 1 every loop\n    - `4` is the number of times the loop will repeat\n- **encapsulation** is when you wrap up code in a function\n    - this gives the code a name, which serves as documentation (noting what its purpose is)\n- **generalization** is adding parameters to a function to make it more ‚Äúcustomizable‚Äù, ex: creating a function that draws a square of *any* size instead of just 1 size\n- the **interface** of a function is a summary of how the function is used, including parameters, purpose, return values\n    - a good interface achieves its purpose without needing to provide unnecessary information\n- **refactoring** is the process of rearranging a program to improve interfaces ‚Äî the goal is to make the code more readable and still be useful\n- **docstrings** are strings at the top of a function that explains the interface (basically describes the purpose of the function)\n    - doc = documentation\n    - also called headers or javadoc comments in Java\n    - all docstrings are *triple-quoted*\n    ```python\n    def polyline(t, n, length, angle):\n        \"\"\"Draws n line segments with the given length and angle (in degrees) between them. t is a turtle.\"\"\"\n        for i in rage(n):\n            t.fd(length)\n            t.lt(angle)\n    ```\n- **preconditions** are things that are required to be true *before* the start of a function, ex: the `angle` parameter has to be a positive value\n- **postconditions** are conditions at the end of the function\n    - if the postconditions are wrong but the preconditions are satisfied, then the bug is within the function\n\n### downey ch5: conditionals ~~and recursion~~\n\n- the **floor division operator** (`//`) divides two numbers and returns the integer (rounds down), ex: `5 // 3 = 1`\n- the **modulus operator** (`%`) divides two numbers and returns the remainder, ex: `5 % 3 = 2`\n- a **boolean expression** will evaluate to either `True` or `False` and uses the `==` operator\n    - `!=` not equal to\n    - `\u003e` greater than\n    - `\u003c` less than\n    - `\u003e=` greater than or equal to\n    - `\u003c=` less than or equal to\n- **logical operators**: `and` `or` `not`\n- `if` statements are *conditional* statements, which check conditions\n    ```python\n    if x \u003e 0: \n        print(\"x is positive\")\n    ```\n    - if there is more than one possibility of the conditional statement, `else` clauses can be added\n        ```python\n        if x \u003e 0:\n            print(\"x is positive\")\n        else: \n            print(\"x is negative\")\n        ```\n    - if there are more than *two* possibilities, use `elif` to define other conditions\n        ```python\n        if x \u003e 0: \n            print(\"x is positive\")\n        elif x \u003c 0:\n            print(\"x is negative\")\n        else: \n            print(\"x is 0\")\n        ```\n- conditionals can also be nested inside each other ‚Äî the next example is a re-write of the previous one\n    ```python\n    if x \u003e 0:\n        print(\"x is positive\")\n    else:\n        if x \u003c 0:\n            print(\"x is negative\")\n        else:\n            print(\"x is 0\")\n    ```\n\n### downey ch6: fruitful functions\n\n- return values are usually assigned to variables or used in an expression\n    - if conditional statements are used, there can be multiple return statements ‚Äî it‚Äôs good practice to make sure the program can return a value no matter which path it takes\n- code that appears *after* a return statement is called **dead code** because it will never be executed\n- **incremental development** is the process of adding and debugging code in small chunks as to avoid long/complicated debugging sessions\n    - comments or tester pieces of code are called **scaffolding** which can be helpful for debugging, but aren‚Äôt part of the final product\n    - start with a working program and make small changes\n    - display intermediate values\n    - remove scaffolding to make code easier to read\n- one function can be called from within another\n- functions can return booleans\n    - common for the function name to be a yes/no question, like `is_even()`, `is_raining()`, or `is_divisible()`\n\n---\n\n## iteration\n\n- control flow diagram for a `while` loop\n    ![while-loop](images/cs220/while-loop.png)\n- basic code for a `while` loop\n    ```python\n    while [condition]:\n        # execute code\n    ```\n- to repeat a loop `n` times, either use `i = 1` and `i \u003c= n` OR `i = 0` and `i \u003c n` because python starts counting from 0 and not 1\n- `break` immediately exits a loop, just like how `return` will immediately exit a function\n- the keyword `continue` will stop the *current iteration* and checks the condition to begin the next iteration\n- loops can be nested\n\n### ch7: iteration\n\n- **reassignment** is when an existing variable is updated to have a new value\n    - equality in python (and other languages) isn‚Äôt achieved through the `=` operator, ex: saying `a = 3` and `a = b` does not mean `b = 3`\n- an **update** is a specific type of reassignment where the new value is dependent on the old value\n    - **increments** are when a variable is updated by adding 1, **decrements** are when a variable is updated by subtracting 1\n- a variable has to be initialized (it has to exist) before it can be updated\n- repetition can be called **iteration**\n- `while` loops will execute as long as the condition remains true after each iteration\n    ```python\n    while n \u003e 0: # while n is greater than 0, display and decrement n\n        print(n)\n        n = n - 1\n    print(\"Blastoff!\")\n    ```\n    - an **infinite loop** is a loop that repeats forever, and occurs when there is no way for the condition to evaluate as false\n- `break` statements can be used to exit loops in the middle rather than at the beginning or end\n- an **algorithm** is a mechanical process for solving problems\n\n### sweigart ch2: flow control\n\ntodo\n\n---\n\n## strings\n\n- python can compare strings just like it can compare numbers with three edge cases: upper vs. lowercase, digits, prefixes\n    - uppercase always comes before lowercase, ex: `\"Z\"` \u003c `\"a\"`\n    - numbers in string form aren‚Äôt actual numbers, they are still considered strings and digits are compared to each place, ex: `\"100\"` \u003c `\"15\"`\n    - prefixes always come first, ex: `\"bat\"` \u003c `\"batman\"`\n- the `isDigit()` function returns if all the characters within a string are digits\n- a **method** is a special function that‚Äôs called on a variable or value, such as `isDigit()` or `upper()`, while functions pass variables or values as parameters\n    ```python\n    msg = \"hello\"\n    \n    msg.isDigit() # method\n    msg.upper() # method\n    \n    len(msg) # function\n    ```\n- **sequences** are collections of ordered values, such as strings, lists, or tuples\n![array](images/cs220/string-array.png)\n- **indexing** a string is when you access a value of the string, while **slicing** is taking a chunk of a string\n    - each character in the string has its own *index* value which is the number to call to retrieve that character\n![indexing](images/cs220/string-indexing.png)\n- both `while` loops and `for` loops can be used to iterate through string\n    ```python\n    msg = \"hello\"\n    \n    # while loop\n    i = 0\n    while i \u003c len(msg):\n        letter = msg[i]\n        print(letter)\n        i += 1\n    \n    # for loop\n    for letter in msg:\n        print(letter)\n    ```\n- `for` loops can also have a *range* which is a way of telling the computer how many times the loop should be executed\n    ```python\n    for i in range(5): # will iterate 0 to 4\n        print(i * 3)\n    \n    \u003e 0\n    \u003e 3\n    \u003e 6\n    \u003e 9\n    \u003e 12\n    ```\n\n### downey ch8: strings\n\n- a string is a *sequence*\n- the **index** is a value that corresponds to a character within a sequence, ex: my sequence is `\"banana\"` and the value at index `1` is `\"a\"` (because python starts counting at 0)\n    - the index has to be an integer value\n- `len()` is a builtin function that returns the number of characters in a string\n- negative indices can be used to count backwards from a string, where the `-1` index returns the last character, `-2` index returns the second-to-last, etc\n- `for` loops can be used to traverse through strings, also called for-each loops\n    ```python\n    fruit = \"banana\"\n    \n    for letter in fruit: # the loop iterates from 0 to 5\n        print(letter)\n    \n    \u003e b # 0th index\n    \u003e a # 1st index\n    \u003e n # 2nd\n    \u003e a # 3\n    \u003e n # 4\n    \u003e a # 5\n    ```\n- string segments are called **slices** which can be obtained using the `[n:m]` operator where the operator includes the `n` letter but not the `m` value, ex: `fruit[1:4]` would return `\"ana\"`\n    - if the `n` is omitted, the slice starts at the beginning and ends at the `m` value, ex: `fruit[:4]` would return `\"bana\"`\n    - if the `m` is omitted, the slice starts at the `n` value and ends at the end of the string, ex `fruit[4:]` would return `\"na\"`\n    - a third argument can be used called *step size* which is the number of spaces between characters, ex: `fruit[0:5:2]` would return `\"bnn\"`\n        - `[start : end : step size]`\n- strings are **immutable** which means an existing string can‚Äôt be changed\n- a **counter** is a variable in a loop that starts at 0 and increments each time a condition is met ‚Äî sometimes the value of the counter is returned at the end of the loop\n- an **invocation** is when a *method* is called on an object, such as the `upper()` method, ex: `fruit.upper()` produces `\"BANANA\"`\n- the `find()` method can return the index where a substring (or character) starts, but it can also take an argument for which index in the string it starts looking at, ex: `fruit.find(\"na\")` produces `2`\n- the `in` operator for strings returns a boolean value if the substring is present in the string, ex: `\"a\" in \"banana\"` returns `True`\n- relational operators (`==`, `\u003c`, `\u003e`) work on strings and are used to put words in alphabetical order, but *all uppercase letters come before lowercase letters*\n\n### downey ch9: case study: word play\n\n- there is a built in function to read files ‚Äî `open( [filepath] )`\n- to read lines of the file, use `readline()`, which will read the next line of the file until it gets to the end of the file\n    - sometimes the lines will end with whitespace characters such as `\\r\\n` which we can get rid of by using the `strip()` function after the `readline()` function\n- the process of reading a file can be made easier by using a `for` loop\n- when testing programs, keep in mind **special cases** which are non-obvious cases that can produce errors, ex: what if a function is called on an empty string?\n\n\u003e Program testing can be used to show the presence of bugs, but never to show their absence! ‚ÄîEdsger W. Dijkstra\n\n---\n\n# state\n\n## lists\n\n- a string is a sequence of characters ‚Äî a list is a sequence of anything!\n    - we can index, slice, and put lists in `for` loops and also use the `len()` function, concatenate with the `+` operator, use the `in` operator to find elements, and multiply by integers\n```python\n# using len()\nmsg = \"321go\"\nlen(msg)\n\u003e 5\n\n# concatenation\nmsg = \"321go\"\nmsg + \"!!!\"\n\u003e \"321go!!!\"\n\n# using in\nmsg = \"321go\"\n\"g\" in msg\n\u003e True\n\n# multiply by int\nmsg = \"321go\"\nmsg * 3\n\u003e \"321go321go321go\"\n```\n$\\phantom{-}$\n```python\n# using len()\nitems = [99,11,77,55]\nlen(items)\n\u003e 4\n\n# concatenation\nitems = [99,11,77,55]\nitems + [1,2,3]\n\u003e [99,11,77,55,1,2,3]\n\n# using in\nitems = [99,11,77,55]\n11 in items\n\u003e True\n\n# multiply by int\nitems = [99,11,77,55]\nitems * 2\n[99,11,77,55,99,11,77,55]\n```\n![string-list](images/cs220/string-list-comparison.png)\n\n### downey ch10: lists\n\n- a **list** is a *sequence*\n    - elements of a list, called **items**, can be of any type (unlike strings, where they have to be characters) ‚Äî they can even be different types than other elements within the same list\n- to create a new list, use square brackets to enclose the elements, ex: `cheeses = [\"Cheddar\", \"Gouda\", \"Mozzarella\", \"Swiss\"]`\n- lists within lists are called *nested* lists\n- empty lists don‚Äôt contain elements and can be created using empty brackets, ex: `empty = []`\n- the bracket operator `[]` can be used to access elements of a list (just like how brackets are used to access characters in a string), ex: `cheeses[1] = \"Gouda\"`\n    - lists are **mutable** which means that elements in the list can be changed\n- the `in` operator can be used on lists to find elements\n- when iterating through lists, the `in` operator will NOT update the elements in the list ‚Äî to update the elements, you have to use `range()` and `len()`\n    ```python\n    cheeses = [\"Cheddar\", \"Gouda\", \"Mozzarella\", \"Swiss\"]\n    \n    for cheese in cheeses: # will NOT change the cheeses list\n        cheese = \"eaten\"\n    \n    for i in range(len(cheese)): # WILL change the cheeses list\n        cheese[i] = \"eaten\"\n    ```\n- the `+` operator will join lists while the `*` operator will repeat a list a given number of times\n- list slicing works the same way as strings ‚Äî using the `[start : end : step size]` operator, sections of lists can be isolated\n- since lists are mutable, a good programming practice is to make a copy of the list before modifying it\n- list methods\n    - `append()` adds a new item to the end of the list\n    - `extend()` takes a list as an argument and adds the entire list to the main list\n    - `sort()` arranges the list elements from low to high\n    - `pop()` removes and returns the final element in a list, or it can remove and return the item at a specified index\n        - the `del` keyword accomplishes the same thing but without a return value\n    - `remove()` removes the item with the specified *value*\n        ```python\n        cheeses = [\"Cheddar\", \"Gouda\", \"Mozzarella\", \"Swiss\"]\n        \n        # the two statements below achieve the same purpose\n        cheeses.pop(1) # used if you know the index\n        cheeses.remove(\"Gouda\") # used if you know the value\n        ```\n- special types of operators\n    - **map** alter every element in a sequence\n    - **reduce** simplifies a sequence of elements into a single value\n    - **filter** removes some elements and returns others, usually according to a user-given rule\n- the `list()` function breaks a string into a list of characters, ex: `list(‚Äùhello‚Äù)` returns `['h', 'e', 'l', 'l', 'o']`\n- the `split()` function breaks a string into a list of words\n    - it can take a **delimiter** as an argument which is a specified boundary to split words\n        ```python\n        delimiter = \"-\"\n        str = \"spam-spam-spam\"\n        \n        str.split(delimiter) # produces [\"spam\", \"spam\", \"spam\"]\n        ```\n- the `join()` function joins a list into a string\n- two lists can be *equivalent*, meaning they have the same elements, but not *identical*, because they are referring to two different objects\n- identical ‚Üí equivalent, but equivalent does not mean identical\n![equivalent](images/cs220/equivalent.png)\n- a variable assigned to an object is called a **reference**, and when an object has more than one reference, that means it is **aliased**\n    - if the aliased object is mutable, then any change will affect all aliases of the object\n- some operations (`append()` , `split()`, `[::]`) modify lists, while other operations (`+`, `*`) create new lists\n\n---\n\n## CSV tables\n\n- CSVs organize cells of data into rows and columns\n    - only holds strings and all text is plaintext\n- **delimiters** are characters that act as separators between objects ‚Äî for CSVs, the delimiter is a comma\n- when a CSV is opened in python, its result is a list of lists (or like a 2D array)\n\n### sweigart ch16: working with CSV files ~~and JSON data~~\n\n- CSV, comma-separated values, are simplified spreadsheets stored as plaintext ‚Äî supported by many types of programs and is very simple, exactly as advertised\n- each row in a CSV file represents a row in a spreadsheet, and each comma represents the next column\n- the `csv` module has a `reader` object which helps the user read the CSV file\n    ```python\n    import csv\n    exampleFile = open(\"example.csv\") # open the file\n    exampleReader = csv.reader(exampleFile) # \"reads\" the file and returns a reader object\n    exampleData = list(exampleReader) # converting data into list\n    \n    exampleData[0][0] # data at row 0, col 0\n    exampleData[0][1] # data at row 0, col 1\n    ```\n    - for larger CSV files, use a `for` loop and load one row at a time\n        ```python\n        for row in exampleReader: # iterating through reader object\n            str(row)\n            # execute code\n        ```\n\n---\n\n## dictionaries\n\n- a **data structure** is a collection of data values, their relationships, and the operations that can be applied to the data\n- **maps** associate values with labels and use labels to lookup values\n    - *lists* are maps which associate indices with values\n- dictionaries map labels (keys, not indices) to values ‚Äî keys must be immutable\n    ```python\n    nums_dict = {\"first\":900, \"second\":700, \"third\":800}\n    \n    nums_dict[\"third\"] # accessing 800\n    ```\n- reminder on parenthetical characters\n    - parentheses `()`: specifying order, calling functions\n    - brackets `[]`: creating lists, indexing, slicing, dictionary lookups\n    - braces `{}`: creating dictionaries, creating sets\n- use the `pop()` method to delete elements in the dictionary ‚Äî by default, `pop()` accepts keys\n- to add elements, assign keys to values using brackets like `d[20] = \"twenty\"`\n- create an empty dictionary `d = {}` or `d = dict()`\n- the `in` operator only checks if keys are present in the dictionary, it does not check for values\n- keys and values can be extracted and turned into lists using `list(d.keys())` or `list(d.values())`\n- use `get()` to return values, `pop()` to delete values in a dictionary and specify a default value if the key doesn‚Äôt exist\n- **bucketing/binning**: dictionary of lists\n![bucketing](images/cs220/bucketing.png)\n- **table representation**: list of dictionaries\n- **probability tables/Markov chains**: dictionary of dictionaries\n![probability-dict](images/cs220/probability-dict.png)\n\n### downey ch11: dictionaries\n\n- dictionaries have **keys** and **values** which make up **items** ‚Äî each key is mapped to a value\n- create a new dictionary using the `dict()` function or two curly brackets `{}`\n    - add elements to a dictionary by using square brackets and assigning a value, ex: `nums[\"1\"] = \"one\"` where `nums` is the dictionary, `\"1\"` is the key, and `\"one\"` is the value\n- dictionaries are not ordered ‚Äî the only thing that matters is the key-value pairs stay the same\n- the `values()` method returns a collection of all the values\n- the `in` operator, `len()` function, and `sorted()` function all work on dictionaries\n- the `get()` method returns the corresponding value associated with a key ‚Äî if there is no value then it returns a default value\n- a list can be a value in a dictionary, in other words, a list can be a value that is assigned to a key:value pair\n    - a list cannot be a key because the keys need to be hashable\n- a **singleton** is a list that contains a single element\n- a **hash** is a special function that takes values of any kind and returns and integer\n    - dictionaries use the integers (called hash values) to store key:value pairs\n    - hashes only work if the object is immutable (and lists aren‚Äôt immutable)\n- a **memo** is a dictionary that can be used to keep track of values that are already known\n    - when calculating the Fibonacci sequence, a memo can be used to store values that were already calculated\n- variables created outside functions are called **global variables** because they are located in the `__main__` frame\n- **flags**, boolean values for conditions, are usually global variables\n    - have to be declared within functions before they can be changed, ex: `global is_called` before using `is_called = !is_called`\n\n---\n\n## JSON\n\n- CSVs are good at storing list of lists, JSONs are good at storing dict of dicts\n\n### sweigart ch16: working with ~~CSV files and~~ JSON data\n\n- JSON, JavaScript Object Notation, stores information as JavaScript source code in plaintext files\n- application programming interface (API) is a way to bridge programs with their applications\n    - lets you scrape raw data from the website\n- the `json` module handles all the stuff between JSON data and python values using `json.loads()` and `json.dumps()` functions\n    - data can be read with the `loads()` function which will return the data as a dictionary\n    - data can be written with the `dumps()` function which can only take dictionary, list, int, float, string, Boolean, or `None` data types and will translate it into JSON data\n\n---\n\n## objects\n\n- using parentheses instead of brackets will create a tuple instead of a list\n    - like a list, `for` loops, indexing, slicing can be done\n- the `namedtuple` object can be imported and it will allow new types to be created\n    ```python\n    from collections import namedtuple\n    \n    Person = namedtuple(\"Person\", [\"fname\", \"lname\", \"age\"])\n    people = [\n        Person(\"Alice\", \"Anderson\", 30)\n        Person(\"Bob\", \"Baker\", 31)\n    ]\n    p = people[0]\n    print(\"Hello \" + p.fname + \" \" + p.lname)\n    \n    \u003e Hello Alice Anderson\n    ```\n- the mutable equivalent of a `namedtuple` is called a `recordclass`, ie: variables can be changed after they have been assigned\n- python uses separate references and objects because: 1) performance; 2) centralized updates\n- the `is` operator will return `True` when two references point to the same object, while the `==` operator only checks if the two objects are equivalent\n\n### downey ch10: lists\n\n- the `is` operator can tell you if two objects are equivalent and identical\n- identical implies equivalent, but equivalent does not imply identical\n\n### downey ch12: tuples\n\n- a tuple (too-ple) is an immutable list usually enclosed in parentheses ‚Äî create an empty one using `tuple()`\n    - can also refer to a group of objects in general\n- the bracket operator (for indexing) and slice operator `[::]` work on tuples\n- for relational operators (`\u003c`, `\u003e`, `=`) work by comparing each element of the tuple until there is a difference, and subsequent elements are not considered\n    - `(0, 1, 2) \u003c (0, 3, 4)`\n    - `(0, 1, 2000000) \u003c (0, 3, 4)`\n- tuples can be assigned in a special way\n    ```python\n    a, b = b, a\n    # tuple of variables on the left\n    # tuple of expressions on the right\n    ```\n    - the number of variables on the left side has to be equal to the number of expressions on the right side\n        ```python\n        addr = \"monty@python.org\"\n        uname, domain = addr.split(\"@\")\n        ```\n- a parameter that begins with `*` will **gather** all arguments into a tuple\n    ```python\n    def printall(*args):\n        print(args)\n    \n    printall(1, 2.0, \"3\") # combines all arguments into tuple\n    ```\n- an argument that uses the `*` operator on a tuple will break the tuple (**scatter**) into multiple arguments (so the opposite of a *gather*)\n    ```python\n    t = (7, 3)\n    divmod(*t) # breaks t into 2 arguments\n    ```\n- the `zip()` function takes multiple sequences and returns a list of tuples where each tuple has an element from each sequence\n    - the zip object is an **iterator** which means that it‚Äôs an object that iterates (moves through) a sequence ‚Äî usually has a `.next()` and no indices\n    ```python\n    s = \"abc\"\n    t = [0, 1, 2]\n    zip(s,t) # creates a zip object\n    \n    for pair in zip(s,t):\n        print(pair)\n    \n    \u003e (\"a\", 0)\n    \u003e (\"b\", 1)\n    \u003e (\"c\", 2)\n    ```\n    - if the sequences are different lengths, the zip object ends when the first sequence ends\n    - this is very useful for traversing through multiple sequences at the same time\n- the `enumerate()` function creates an enumerate object, or a sequence of pairs matching an index to an element in the argument\n    ```python\n    for index, element in enumerate(\"abc\"):\n        print(index, element)\n    \n    \u003e 0 a\n    \u003e 1 b\n    \u003e 2 c\n    ```\n- dictionaries have a method called `items()` that returns a sequence of tuples of key:value pairs\n- a list of tuples can be initialized into a new dictionary using `dict()`\n- tuples are commonly used as keys in dictionaries because lists can‚Äôt be used as dictionaries (tuples are immutable, lists are not)\n\n---\n\n## copying\n\n- slicing creates a new object\n- three levels of copying\n    - reference copy (0 levels): fastest but most dangerous, only creates a pointer to the object ‚Äî any changes to either object will change both\n    - shallow copy (1 level): used to copy an object (ie, a list) so the original doesn‚Äôt get corrupted, but it only makes a new object (a new list) that refers to the same original objects\n        - helpful for reorganizing object positions like sorting a list or dictionary, but not helpful if you want to change values\n    ![shallow-copy](images/cs220/shallow-copy.png)\n    - deep copy (all levels): slowest but the safest, copies everything including sub-lists and sub-dictionaries ‚Äî any changes made in the copy is not reflected in the original\n\n### sweigart ch4: lists\n\n- when assigning lists to variables, a *reference* to the list is what‚Äôs stored, not the actual list itself\n    - so if two variables point to the same list, then any change made on one variable will reflect on the other\n- python uses **references** when storing values of mutable types, like lists or dictionaries; it will store actual values for immutable types like strings, ints, or tuples\n    - even though lists and dictionaries are passed by reference through functions, they will still be altered directly\n- the `copy` module provides a `copy()` and `deepcopy()` function that makes duplicate copies of dictionaries or lists (and not just references)\n    - if the copy contains lists, use `deepcopy()` because it will copy inner lists\n\n---\n\n## recursive functions\n\n- a tree is an example of recursion where there are **recursive** cases (branches) and **base cases** (leaves)\n- a **recursive** function calls itself, directly or indirectly\n- both iteration and recursion achieve the same purpose but often one is more efficient or easier to implement than the other\n- an example using factorials\n    ```python\n    def fact(n):\n        if n == 1:\n    \t    return 1\n        p = fact(n-1)\n        return n*p\n    ```\n- variables exist in a frame, which are stored in stacks ‚Äî only the topmost frame is active at a time\n\n### downey ch5: ~~conditions and~~ recursion\n\n- a function that calls itself is a **recursive** function and executing that function is called **recursion**\n- a **base case** is the last call of the recursive function and it does not make another call\n    - if a recursion never reaches a base case, then it‚Äôs an **infinite recursion** and the program will never end\n\n### downey ch6: fruitful functions\n\n- return values are passed back up the recursion stack\n- an example with the Fibonacci sequence\n    ```python\n    def fibonacci(n):\n        if n == 0:\n    \t    return 0\n        if n == 1:\n    \t    return 1\n        else:\n            return fibonacci(n-1) + fibonacci(n-2) # calls itself\n    ```\n- sometimes the the function can miss the base case and keep recursing, so it‚Äôs good practice to make sure the input to the function is legal\n    - a **guardian** is a chunk of code that protects the code from executing on the wrong arguments\n\n---\n\n## function references\n\n- functions are objects, so they behave like objects\n    - can be referenced by variables, lists, or dictionaries; pass function references to other functions\n- if two different variables are assigned to a function, then both variables can call the function\n    ```python\n    def f():\n        return \"hi\"\n    \n    g = f\n    \n    f() # returns \"hi\"\n    g() # also returns \"hi\"\n    ```\n- function invocations have parentheses, function references *do not*\n- method references can be passed through parameters if the module name is used in the function invocation like, ex: `str.upper(val)` does the same thing as `val.upper()` but using `f = str.upper`, we can call `f(val)`\n- the `sorted()` function has a `key` parameter that allows you to choose what to sort the items by, and the `key` can be a function reference\n    - `attrgetter` is for namedtuples, `itemgetter` is for lists(?)\n\n---\n\n## generator functions\n\n- for recursive functions, make sure the arguments are changing and will at some point hit the base case\n- an eager function will finish execution before returning the end value, whereas a lazy function returns a value at each step and needs to be prompted to return the next value\n- a **generator** can stop and return a value and then execute more code after\n    - use the `yield` keyword\n    ```python\n    def f():\n        yield 1\n        yield 2\n        yield 3\n    \n    for val in f():\n        print(val) # printed once every loop\n    \n    \u003e 1 # goes back to executed yield 2\n    \u003e 2\n    \u003e 3\n    ```\n- multiple instances of the same generator can be executing at the same time\n- the `next()` function is built for generator objects and it will iterate through a generators\n    - by default, generator objects (from yield statements in functions) will create generator instances which can be used by `next()`... I think‚Ä¶\n- an **iterable** is something that can be iterated over, such as sequences like list, tuple, ranges, or `dict.keys()` or `dict.values()`\n    - an **iterator** object is an *iterable* object and can be created for *any iterable object* ‚Äî it‚Äôs a special object with the `next()` function\n- is `iter(x)` works, then `x` is iterable; if `next(x)` works, then `x` is an iterator\n\n---\n\n## error handling\n\n- turn semantic errors into runtime errors\n- a string can be formatted using brackets and `.format()`\n    - `\"area={:.2f}\".format(2.29834)` will print to `2.29` (CHECK)\n- anything that can be used in a boolean statement can also be used in an **assertion** which will throw an error and end the program if it‚Äôs false\n- the `try` and `except` blocks let you run code even after it crashes ‚Äî any errors thrown in the `try` block will prompt the `except` block to run\n    - when an error occurs in a `try` block, the program tries to find the closest `except` block to execute ‚Äî python will exit functions or loops until it can raise the exception\n- specific exceptions can be specified using `Exception` objects\n    ```python\n    try:\n        print(1/0) # buggy code\n    except Exception as e:\n        print(\"An exception was raised: \" + str(e) + \" \" + type(e))\n    ```\n    - it‚Äôs good practice to get very specific about exceptions so the user knows what went wrong\n- to crash the program manually, raise an exception with `raise [Exception](\"error message\")` ‚Äî the program will search for an `except` clause\n\n### sweigart ch10: debugging\n\n- python raises **exceptions** when the code is wrong but exceptions can also be manually raised using `raise Exception(\"error message\")`\n- **tracebacks** can tell you which line the error appeared on\n- there is a `traceback` module that allows you to manually deal with bugs and output them to log files, which means the program will keep running even if exceptions are thrown in the background\n- an **assertion** is a sanity check to make sure the code is doing what it‚Äôs supposed to do, ex: `assert [condition], \"[error message]\"`\n    - if an assertion fails, the error message is displayed and an `AssertionError` is thrown\n\n---\n\n# data science\n## files and directories\n\n- `f = open(\"path\")` will open a file and allow you to read from and write to `f`\n    - always close your files after using them!\n- to read a file, either use `read()` to return the *entire file content* into a string, `next()` to get one line of the file at a time, or `list()` to turn the file contents into a list\n- the `write()` function allows you to write to a file\n- the `os.path.join()` function will join parts of a path together ‚Äî this is useful because different OS use different forward and backward slashes and this function allows your code to run on multiple platforms\n- **encoding** is taking data and making it readable to the computer, while **decoding** is taking computer-language and making it readable to a human\n- the best way to parse data from large files is to use a generator to turn the data into a stream\n- using `with open(\"path\") as f:` will accomplish the same thing as just using `open()` but it‚Äôs faster (because whole data isn‚Äôt moved into memory) and the closing clause isn‚Äôt required\n- `json.dump(\"file\", [file object])` is the equivalent of `json.dumps(\"file\")` and `f.write()`\n- `data = json.load(f)` is the equivalent of `f.read()` and `json.loads()`\n- `os.path.basename(path)` names the file at the end of the path\n\n### downey ch14: files\n\n- **persistent** programs run all the time and permanently store some of their data ‚Äî this includes OS and web servers\n- to write to a file, it has to be opened in ‚Äúwrite mode‚Äù using `open(\"file path\", \"w\")`\n- the **format operator** is `%` and is preceded by a **format sequence**, ex `\"%d\"` is the sequence to format an argument as a decimal integer within the string\n    ```python\n    camels = 42\n    print(\"I have spotted %d camels.\" % camels)\n    \u003e \"I have spotted 42 camels.\"\n    ```\n    - there is also `\"%g\"` for floating-point numbers and `‚Äú%s‚Äù` for strings\n    - the number of format sequences must match the number of arguments that come after the format operator\n- **directories** are also called folders\n- a **relative path** specifies where a file is located with respect to the ‚Äúcurrent working directory‚Äù, while an **absolute path** specifies how to get to a file from the root of the entire system\n- the `os` module (stands for ‚Äúoperating system‚Äù) includes functions for working with files and directories ‚Äî `os.path.abspath()` to find absolute path, `os.path.exists()` to check if a file or directory exists, etc‚Ä¶\n- a **database** is like a permanent dictionary that organizes data ‚Äî python offers the `dbm` module to work with databases\n    - each item in the database has an associated **bytes object**\n    - the `pickle` module translates any object into a string to be stored in a database\n- any program that can be launched from the shell, can also be launched from within python using a **pipe object**\n- any file with python code in it can be imported as a module\n\n---\n\n## pandas\n\n- tabular data is data that is organized with tables and columns ‚Äî using the `pandas` module to order this data is much easier than using lists\n    - Pandas tables are built using `Series` which is a special data structure\n- pandas terminology\n    - *integer position* is a label like 0, 1, 2, that is equivalent to a list‚Äôs index\n    - *index* is equivalent to a dict‚Äôs key\n- lookup values using indices (keys) `.loc[\"key\"]` or lookup by integer positions (index) `.iloc[\"index\"]`'\n    - negative indexing isn‚Äôt supported by Series\n    - new slices are not indexed from 0\n- operations on Series work like vector math ‚Äî the operation is applied to every element\n    ```python\n    nums = Series([100, 200, 300])\n    nums + 1 # adds one to every element\n    \n    Series([1,2,3]) * 3 # multiples all elements by three\n    \n    Series([10,20]) + Series([3,4]) # results in Series([13, 24])\n    ```\n    - comparisons can also be done (`%`, `\u003e`, `==`)\n- boolean indexing is where you take every value in a Series that matches to `True` in a boolean Series, also called ‚Äúfancy indexing‚Äù\n    ```python\n    letters = Series([\"A\", \"B\", \"C\", \"D\"])\n    bool_series = Series([True, True, False, False)]\n    \n    letters[bool_series]\n    \u003e 0    A\n    \u003e 1    B\n    \n    letters[Series([False, True, False, True])\n    \u003e 1    B\n    \u003e 3    D\n    ```\n- example combining operations and fancy indexing\n    ```python\n    S = Series([1,9,2,3,8])\n    B = S \u003e 5 # Series that evaluates to True at any index where S\u003e5\n    \n    S[B] # filtering out values in S\n    \u003e 1    9\n    \u003e 4    8\n    ```\n- use and `\u0026`, or `|`, not `~` when chaining multiple conditionals for fancy indexing\n- a `DataFrame` is a table of aligned Series\n- calling a comparison function will compare Series even if the indices are mismatched (keys/indices are arranged wrong) ‚Äî `gt()`, `eq()`, `ge()`, `le()`...\n- a DataFrame is made up of a dictionary of Series but it could be a dict of lists, a list of lists, dict of dicts, list of dicts\n    - the indices can be specified when creating a DataFrame, ex: `DataFrame({data}, index=[\"row titles\"])`\n- to access a single cell in a DataFrame, use `loc[row,col]`\n- to read a CSV file, use `pd.read(\"file path\")` which will automatically add it as a DataFrame\n\n---\n\n## web\n\n- manual downloading is tedious; datasets are difficult to download in complete\n- every machine has an IP address and requests are sent between IPs but nicknames (domains) are easier to remember and are often used in place of IPs\n    - ports are specific locations on the ends of IP addresses\n    - domain: which computer; port number: which program; file name: which data\n- a URL puts together all elements of a request to a machine, ex: `https://en.wikipedia.org:443/wiki/URL`\n- `GET` specifies that we want to get data from the remote server; `POST` means we are uploading data to the server\n- status codes\n    - 200 is good\n    - 404 is the file isn‚Äôt available (file not found)\n    - 500 is a server error\n- all data parsed from webpage is formatted in a single string (I think)\n    - the shortcut to turn a .json file into a dict is `[requests.get('url')].json`\n- hypertext is text that is clickable links\n- browser sends a URL (domain, port, file) HTTP request\n- HTML stuff\n    - tags `\u003cb\u003e`, `i`, `u`..., allow you to group pieces of content together and apply special effects\n    - hyperlinks: `\u003ca href=\"[link]\"\u003e\u003c/a\u003e`\n    - images: `\u003cimg src=\"source\"\u003e`\n    - tables: `\u003ctable\u003e`, rows `\u003ctr\u003e`, cell `\u003ctd\u003e`\n- python can convert to html by outputting (`open(html_path, ‚Äúw‚Äù)`) to a .html file\n    - each tag has to be written to the file‚Ä¶ it‚Äôs not like .csi files in java where the code is mixed\n- BeautifulSoup allows for searching within HTML files\n- the browser takes HTML and generates a DOM (Document Object Model) Tree\n![dom-tree](/images/cs220/dom-tree.png)\n- BeautifulSoup creates a new DOM object when using `BeautifulSoup([data], [parser])`\n    - the `find_all()` function will return a list of all elements with that tag ‚Äî `find()` returns the first instance\n    - once the elements are found, use the `get_text()` function which will parse the text within those elements\n- if there are nested tags within an element, use the `.children` attribute which will return a list of the children tags of the parent element\n- most websites have a `robots.txt` file which will tell you what‚Äôs allowed and disallowed when ‚Äúcrawling‚Äù (pulling data from) in their site\n\n### sweigart ch11: web scraping\n\n- **web scraping** is downloading and processing content from the web\n- the `requests` module lets you download files from the web (has to be install from cmd)\n    - `requests.get()` returns a Response object\n        - `raise_for_status()` checks for if the request went through ‚Äî will produce errors like 404 not found, etc\n- save and write the web page to a file\n    ```python\n    res = requests.get('https://automatetheboringstuff.com/files/rj.txt')\n    res.raise_for_status()\n    playFile = open('RomeoAndJuliet.txt', 'wb')\n    for chunk in res.iter_content(100000): # chunks in bytes\n    \t\tplayFile.write(chunk)\n    \n    playFile.close()\n    ```\n- the Beautiful Soup (bs4) module parses HTML files in the drive\n    - why is web parsing and pandas more tedious to read than the entire two units of this course combined? this is an absolute slog and idk what‚Äôs going on even\n    - `exampleSoup = bs4.BeautifulSoup(open(\"example file\"))`\n    - the `select()` method will parse specific CSS syntax, ex: `soup.select(\"div\")` will find all elements named `\u003cdiv\u003e`\n- the `selenium` module can directly control the browser by clicking links and filling in login information\n- the shortcut of performing an action to every element in a list is `new_list = [action for x in old_list]` ‚Äî called list comprehension\n- defaultdict is a dict object that gives a default value to a key if it doesn‚Äôt exist in the dict yet\n\n---\n\n## databases\n\n- SQL databases are collections of named tables where all columns have an enforced type ‚Äî CSV files are just one table of strings\n    - can keep multiple copies of the same data stored in different ways to make retrieval efficient\n- SQL (structured query language) servers include Oracle, MySQL, SQLite\n- `sqlite3.connect(filepath)` is basically opening the file and will return a Connection object\n    - use pandas to read everything in the db `pd.read_sql(\"SELECT * FROM sqlite_master\", [connection obj])` and save it into a DataFrame to parse\n- SQL has different type names: `INTEGER`, `REAL`(float), `TEXT`(str)\n- `CREATE TABLE` signifies new table and will be followed by the table name\n- to get data and narrow down to to specific cells, start with `SELECT [ ] FROM [table name];` and follow in the order below\n    - `SELECT` which columns\n    - `FROM` which table\n    - `WHERE` which rows; filtering in the original table\n    - `GROUP BY` groups into categories (buckets)\n    - `HAVING` which rows, filters from the sorted groups above\n    - `ORDER BY` sorts the data ‚Äî `ASC` ascending, `DESC` descending\n    - `LIMIT` how many rows\n- the `AS` keyword creates a new column and can be used later\n- aggregate queries\n    - `COUNT()` counts the number of items in a col\n        - use `DISTINCT` to remove duplicates\n    - `SUM()` adds entire col together\n    - `AVG()` averages a col\n![sql-sequence](/images/cs220/sql-sequence.png)\n\n---\n\n## plotting\n\n- pandas Series and DataFrames integrates with matplotlib\n    - `[Series].plot.pie(figsize=(width, height), color=\"\")` makes a pie chart out of a Series\n    - `[s,df].plot.bar()` makes a bar plot\n        - the Series object can be directly altered before it‚Äôs plotted, ex: `([Series] / 100).plot.bar()` will divide all elements in the Series by 100 and plot accordingly\n        - the DataFrame bar plot takes a parameter `stacked=` which will make a stacked bar plot\n    - `[DataFrame].plot.scatter(x=\"\", y=\"\")` makes a scatter plot out of a DataFrame\n        - `s=` size of the points\n        - `c=` color of the points\n            - `vmin` takes a floating-point value that restricts the b/w of the plot points‚Ä¶\n        - `marker=` shape of the points `\"o\"` `\"+\"` `\"^\"` `\"v\"`\n        - set the limits of x and y axes using `xlim=` and `ylim=`\n    - `[s,df].plot.line()` line plot for Series or DataFrame\n        - the index is the x-axis unless otherwise specified\n            - for Series, use `s.sort_index()`\n- change default plot settings (like font size) by calling `matplotlib.rcParams[\"setting\"]`\n- once a plot is made, it returns an AxesSubplot object which can be tweaked\n    - `plot.set_title(\"title\")`\n    - `plot.set_ylabel(\"label\")`\n    - `plot.set_xticklabels(list([Series].index), rotation=)` sets the orientation of the x-axis labels\n    - `plot.splines[‚Äùright‚Äù, ‚Äútop‚Äù, ‚Äúbottom‚Äù, ‚Äúleft‚Äù].set_visible[True, False]`\n        - splines are the edges of the graph\n- it‚Äôs good practice to make a function that makes your plots look the same\n    - the main plot can be divided into subplots which you can specify settings for\n    - `fig, ax = plt.subplots()` and then customize the axis\n- set the index of a DataFrame using `[DataFrame].set_index()` to have custom tick labels\n    - tick positions also need to be set with `[df.plot.line()].set_xticks([list])`\n- define a custom header of a DataFrame using the `name=` parameter\n- to make a scatter plot for multiple classes, you have to loop over each class while plotting on the same `AxesSubplot`\n    - define a list of colors to change colors as you loop through classes `colors = []`\n    - add a legend using `label=` and the title of the class\n- use `cumprod()` to find the cumulative product\n- with large amounts of data, only present the important percentiles (using `.quantile(percentile=, axis=[column])`)and not the whole set of data\n- drop NaN values using `dropna()`\n- verify that data points aren‚Äôt being cut off in a plot using `assert` statements to compare `xlim` and `ylim` with the max values of x and y axes\n    - ex: `assert [df[axis]].max() \u003c= [ax].get_xlim()[?]` 0 or 1‚Ä¶?\n- log base 10 refocuses into how long the number is (how many 0s) instead of digits ‚Äî logarithmic scale is used so small values aren‚Äôt ‚Äúbrushed aside‚Äù when plotting\n- `plot.subplots()` can take a parameter `ncols=` and `nrows=` which will create multiple AxesSubplot objects\n    - to ensure the same y-axis across multiple graphs, use the parameter `sharey=True`\n\n---\n\n## randomness\n\n- `random.choice([list])` returns a random value from the list (using the `random` module) ‚Äî sampling with replacement\n    - `random.choices([list], size=)` returns `size` random values ‚Äî `size` can also be a tuple to generate multidimensional arrows (row, col)\n    - takes a parameter `p=` where the probability can be predetermined\n- how do we know if something is really random? look at a large sample size\n- seeds are predetermined random sequences ‚Ä¶ like Minecraft\n    - it‚Äôs easier to debug errors that depend on randomness if the randomness can be controlled through seeds\n- large difference in a small data set, or a small difference in a large data set means it might not be random","lastmodified":"2022-08-28T03:22:22.605483999Z","tags":null},"/notes/cs61a":{"title":"CS 61A: Structure and Interpretation of Computer Programs","content":"# content\n\n## functions\n\n### ch1.1: getting started\n\n- Python devs emphasized human interpretability of Python code ‚Äî easy to read/understand\n- an interactive session is signaled by the `\u003e\u003e\u003e`\n- statements describe actions; expressions describe computations\n\n### ch1.2: elements of programming\n\n- any powerful programming language should be able to describe data and functions, or, ‚Äúhave data and process it‚Äù\n- expressions describe a computation and evaluates it to a value\n    - infix notation is when operators (`+`, `-`, `*`, `/`) appear between operands (the numbers)\n    - all expressions can be generalized to **function notation**\n- a **call expression** applies a function to some arguments\n- not all functions are available by default and many have to be imported through **modules**\n- `=` is the assignment operator, which matches names to the results of compound operations or to functions\n    - the names are remembered by Python‚Äôs interpreter, which means that the interpreter has some kind of memory ‚Äî the memory is an **environment**\n- nested function calls repeated the same procedure until the expression is evaluated: first evaluate the operator (function) and then its operands (arguments)\n- **pure functions** have an input and an output and will *always return the same output for the same input*\n    - can‚Äôt have side effects or change behavior over time, making them reliable\n    - simpler to test\n- **non-pure functions** change the state of the interpreter or computer, ex: `print`\n- a function that doesn‚Äôt specify a return value will return `None`\n\n### lecture\n\n- every expression in Python is generalized to *function call notation*\n- any call expression is made up of an operator and its operands, which are also expressions (possibly made up of more operators and operands)\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/842fac8d-b39a-4a12-992a-f06ff4acdc46/Untitled.png)\n\n- three ways to bind values to names: importing modules, assignment, and `def` statements (functions)\n- with a frame, a name can only be bound to one value\n- Python evaluates all the expressions to the right of the assignment operator `=`, and then it binds the resultant values to the name(s) on the left\n- **abstraction** is the process of naming something complex and treating it as a whole entity without worrying about its details\n    - functions are a form of abstraction:\n        ```python\n        def \u003cname\u003e(\u003cformal parameters\u003e):\n            return \u003creturn expression\u003e\n        ```\n        - the function *signature* (first line) defines how many arguments a function will take ‚Äî the signature is the name of the object\n        - the function *body* (remainder) is where the computational process happens\n- an *environment* is a sequence of *frames*\n    - a **frame** is a bit of a memory that keeps track of what names mean (it‚Äôs also called a scope)\n    - any name evaluates to the assigned value in the closest frame, starting with the local frame and working towards the global frame\n- to use a local variable from the global frame, you have to return the local variable first (assuming it‚Äôs a function call)\n\n---\n\n## control\n\n### ch1.3: defining new functions\n\n- to define a function is to give a name to a compound operation, which allows the operation to be referred to\n- the `def` statement and the assignment operator `=` bind names to values ‚Äî any previously bindings are lost\n- bindings exist in *frames* which are layered\n    - a local frame is created every time a function is called\n        - a name only exists in that frame for as long as the frame exists, ie once the function call is over, any bindings within the function will disappear\n- the **scope** (existence) of a local name is limited to its function or its frame\n- functional abstraction is the idea that the only thing that matters about a function is its return value, and not the process which that value is computed\n    - three core values to functional abstraction: *domain*, or the set of arguments of a function; *range*, or the set of values it can return; *intent*, the relationship between the inputs and outputs\n\n### ch1.4: designing functions\n\n- a function should have exactly one job\n- don‚Äôt repeat yourself ‚Äî if you are copy-pasting code, it can probably be turned into a function\n- triple quoted docstrings at the top of a function body typically describe what the function does\n    ```python\n    def pressure(v, t, n):\n        \"\"\"Compute the pressure in pascals of an ideal gas.\n    \n        Applies the ideal gas law: http://en.wikipedia.org/wiki/Ideal_gas_law\n    \n        v -- volume of gas, in cubic meters\n        t -- absolute temperature in degrees kelvin\n        n -- particles of gas\n        \"\"\"\n        k = 1.38e-23  # Boltzmann's constant\n        return n * k * t / v\n    ```\n- default function values can be specified in the function signature\n\n[stopped reading the textbook lol]\n\n### lecture\n\n- Python‚Äôs interactive interpreter will print any value returned from an expression or function that isn‚Äôt `None`, which represents nothing\n- **pure functions** return values and have the same output for the same input\n- **non-pure functions** have an input and output but something else happens before the output, like some text being printed to the terminal\n- a `def` statement is how a function is created ‚Äî includes the signature and body, which are bound to the name of the function\n    - the frame isn‚Äôt created until the function is called\n- multi-frame environments consist of a global frame and then local frames\n    - a *name* evaluates to the earliest assigned instance of a value to that name, whether that be in the local frame or otherwise\n- there are two kinds of division\n    - `/` is called **true division** which divides like normal, ex: `2013 / 10` evaluates to `201.3`\n    - `//` is called **floor division** which rounds down to the nearest integer, ex: `2013 / 10` evaluates to `201`\n- to return multiple values from a function, use a comma\n- Python can run in a file, run in the interactive mode, or run a file in interactive mode\n- Python can run an interactive session by taking code from a function‚Äôs docstring\n    ```python\n    def divide_exact(n,d):\n        \"\"\"Return the quotient and remainder of dividing n by d.\n    \n        \u003e\u003e\u003e q, r = divide_exact(2013, 10)\n        \u003e\u003e\u003e q\n        201\n        \u003e\u003e\u003e r\n        3\n        \"\"\"\n        return floordiv(n, d), mod(n, d)\n    \n    python3 -m doctest -v [\"filename\"]\n    ```\n- use the `if`, `elif`, `else` to execute a suite (set of statements after a header) that evaluate to true to a boolean statement\n- **boolean statements** will always evaluate to either `True` or `False`\n    - false values: `False`, `0`, `\"\"`, `None`\n    - true values: anything that isn‚Äôt false\n- **iteration** allows us to repeat stuff\n    - for a `while` loop, we evaluate the header‚Äôs boolean expression, and then execute the following suite and evaluate the header again\n\n---\n\n## higher-order functions\n\n- characteristics of functions\n    - **domain**: the set of all inputs as arguments\n    - **range**: the set of all outputs\n- each function should have exactly one general job\n- an `assert` keyword can be followed by a boolean expression that will throw an error if the expression evaluates to false\n    - this is useful for checking if given arguments are within specifications\n- a higher-order function is a **first-class value**, and can take another function as an argument, or can also be returned as a return value\n    ```python\n    def make_adder(n):\n        \"\"\"Return a function that takes one argument k and returns k + n.\n    \n        \u003e\u003e\u003e add_three = make_adder(3)\n        \u003e\u003e\u003e add_three(4)\n        \"\"\"\n        def adder(k):\n        \treturn k + n\n        return adder\n    ```\n    - the function `adder` is returned from `make_adder` and assigned to `add_three` with `n=3`\n- **lambda expressions** are expressions that evaluate to *functions* ‚Äî use the `lambda` keyword, ex: `square = lambda x: x*x` ‚áí `square(4)` evaluates to 16\n    - the function name can be skipped and directly called, ex: `(lambda x: x*x)(4)` evaluates to 16\n- lambdas can‚Äôt use conditionals while `def` statements can; `def` statements give functions a name while lambdas don‚Äôt (it‚Äôs just called a lambda)\n- `and` and `or` are logical operators which don‚Äôt require all statements to be checked to evaluate fully\n    - for `and`, if the first statement is false, then the whole statement is false\n    - for `or`, if the first statement is true, then the whole statement is true\n        - ex: `return (n==0) or (1/n != 0)`, the expression wouldn‚Äôt throw a zero-division error because `n==0` evaluate to true first so true is returned without considering the second expression\n- a conditional expression can take the form `\u003cconsequent\u003e if \u003cpredicate\u003e else \u003calternative\u003e`\n    - the `\u003cpredicate\u003e` is evaluated first, and if it‚Äôs true, the expression evaluates to the `\u003cconsequent\u003e` value\n    - if `\u003cpredicate\u003e` is false, then the expression evaluates to `\u003calternative\u003e`\n    ```python\n    print(\"cons\" if 2==2 else \"alt\")\n    # prints cons\n    print(\"cons\" if 2==3 else \"alt\")\n    # prints alt\n    ```\n    \n---\n\n## environments\n\n- a **higher-order function** is a function that can take another function as an argument, or returns another function as a return value\n- a return statement brings information from a local frame into a global frame (or similar)\n- the parent frame of a frame created from a *returned function* is the *frame where that function was created*, which means that function has access to its parent frame values\n    - below: `make_adder` returns a function `adder` in frame `f1`; when the new `add_three` function (a sub-function of `adder`) is called, it can access values in its parent frame, `f1`\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/362c7ba7-1e7a-4396-9950-bce935d315c0/Untitled.png)\n\n- the environment created by calling a top-level function consists of a local frame followed by the global frame\n- a function can return itself, which can lead to the same function being called on multiple arguments in the same line of code\n    - the function does not run forever because the return value is only a function object, and not a call to that function\n    ```python\n    def print_all(x):\n        print(x)\n    \treturn print_all\n    \n    print_all(1)(3)(5)\n    \n    # 1\n    # 3\n    # 5\n    ```\n- **currying** is transforming a multi-argument function into a single-argument, higher-order function\n    - when calling `add_three`, it has access to the `f2` and `f1` frames which store the variables `x` and function `f`\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/03c73182-193c-4b20-bfc0-6780eda374d5/Untitled.png)\n\n---\n\n## design\n\n- **abstraction** is giving a name to a process and referring to it as a whole and not worrying about the details of the process\n    - function names don‚Äôt matter for correctness of a program, but they matter to humans :(\n- a **docstring** is the best way to document a function‚Äôs purpose\n- a **syntax error** is detectable before the program starts executing and they are caused by errors in the form/language of the code, ex: unclosed parentheses\n- a **runtime error** is detected by the interpreter while the program is executing, ex: `TypeError` which occurs when math doesn‚Äôt work out between objects of different types‚Ä¶\n- a **logical error** isn‚Äôt detected at all, the program runs but doesn‚Äôt do as expected\n- a **decorator** is a function that goes at the top of a function, which is called on the function\n    ```python\n    @trace\n    def triple(x): # calls trace on triple\n        return 3*x \n    ```\n\n---\n\n## recursion\n\n- a **recursive function** is a function that calls itself\n    - uses conditional statements to check for base cases ‚Äî usually doesn‚Äôt end in a recursive call, and a value is directly returned\n    - each call to the function will solve a simpler problem than the last call (smaller `n`)\n- mutual recursion is when two different functions call each other, ex: Luhn algorithm\n- iteration is a special case of recursion\n    - to convert from recursion to iteration, you need to figure out what *state* has to be maintained after each recursive call (which should match to each iterative call‚Ä¶)\n\n---\n\n# homework\n\n### disc 01: control, environment diagrams\n\n- **conditional statements** let programs execute different lines of code depending on what conditions are true or false\n    - general form of an `if` statement\n        ```python\n        if \u003cconditional expression\u003e:\n            \u003csuite of statements\u003e\n        elif \u003cconditional expression\u003e:\n            \u003csuite of statements\u003e\n        else:\n            \u003csuite of statements\u003e\n        ```\n    - general form of a `while` loop\n        ```python\n        while \u003cconditional clause\u003e:\n            \u003cstatements body\u003e\n        ```\n- `not` `and` `or` are boolean operators that manipulate boolean expressions\n- a `def` statement defines a function object\n    - call expressions apply functions to arguments\n\n### lab 01: variables \u0026 functions, cont\n\n- `\u003e\u003e\u003e True and 12` displays `12`\n- `\u003e\u003e\u003e False or 0` displays `0` (I assume because the statement evaluates to `False` and `0` is the last evaluated expression?)\n- `\u003e\u003e\u003e not 10` displays `False` because `10` is a truthy value\n- `\u003e\u003e\u003e not None` displays `True` because `None` is a falsey value\n- `\u003e\u003e\u003e True and 0` displays `0` (because last evaluated expression is `0`?)\n- `\u003e\u003e\u003e 0 or False or 2 or 1/0` displays `2` because `2` is the expression that makes the statement be true\n- I think that what gets printed by the interpreter is the last evaluated value that makes the expression be true or false!\n- use `python3 ok -q [\"question\"] -i` to open an interactive terminal for the question\n- use `python3 ok -q [\"question\"] --trace` to look at an environment diagram for the question\n\n### lab 02: higher-order functions, lambda expressions\n\n- transforming a function `f(x,y)` into `g(x)(y)` is known as currying\n    ```python\n    def lambda_curry2(func):\n        return lambda x: lambda y: func(x,y)\n    ```\n- sometimes, trying to refer to a variable in the parent frame won‚Äôt work ‚Äî use the `nonlocal` keyword to reframe the variable\n    - idk why it doesn‚Äôt work\n- Church numerals‚Ä¶\n\n### disc 02: higher-order functions, self reference\n\n- a lambda expression doesn‚Äôt return anything until the lambda is called\n- the parent of any function is the frame where the function is defined ‚Äî variables can be included in the parent frame, which can also be accessed in the function‚Äôs frame (sometimes use `nonlocal`)\n- self-reference is when a function *returns* itself, but doesn‚Äôt *call* itself\n\n### disc 03: recursion\n\n- three parts to a recursive function\n    - **base case**: the stopping condition, the simplest case, ex: $0! = 1$\n    - **recurse onto smaller problems**: to recursively call on a simpler problem than the current one and breaking it into parts\n    - **solve the big problem in parts**: since we can solve many small parts, use that to solve the bigger parts","lastmodified":"2022-08-28T03:22:22.605483999Z","tags":null},"/notes/fa22/cs475":{"title":"CS 475: Introduction to Combinatorics","content":"","lastmodified":"2022-08-28T03:22:22.605483999Z","tags":null},"/notes/fa22/ece252":{"title":"ECE 252: Introduction to Computer Engineering","content":"","lastmodified":"2022-08-28T03:22:22.605483999Z","tags":null},"/notes/fa22/ece537":{"title":"ECE 537: Communication Networks","content":"","lastmodified":"2022-08-28T03:22:22.605483999Z","tags":null},"/notes/fa22/physics201":{"title":"PHYSICS 201: General Physics","content":"","lastmodified":"2022-08-28T03:22:22.605483999Z","tags":null},"/stream":{"title":"Stream","content":"This serves as a hub for all of my recent edits on my website. All of my writing is organized into three categories ‚Äî **seed** (üå∞) for quick thoughts, **leaf** (üåø) for revised ideas, and **fruit** (ü•≠) for completed blog posts.\n\n- üåø `::` [NOTES - 6.042J: Mathematics for Computer Science](https://emilyyao.me/notes/6-042j)  \n- üåø `::` [NOTES - CS 61A: Structure and Interpretation of Computer Programs](https://emilyyao.me/notes/cs61a)  \n- ü•≠ 22-07-16 `::` [Summer Exploration Arc #3](https://emilyyao.me/2022-sea3)\n- üåø 22-07-14 `::` [NOTES - CS 220: Data Programming I](https://emilyyao.me/notes/cs220)\n- üå∞ 22-07-08 `::` [Installing Ubuntu 22.04 on macOS Monterey using UTM](https://emilyyao.me/utm-ubuntu)\n- ü•≠ 22-06-26 `::` [Summer Exploration Arc #2](https://emilyyao.me/2022-sea2)\n- ü•≠ 22-06-11 `::` [Summer Exploration Arc #1](https://emilyyao.me/2022-sea1)","lastmodified":"2022-08-28T03:22:22.605483999Z","tags":null},"/utm-ubuntu":{"title":"Ubuntu 22.04 with UTM","content":"- No easy way to dual boot with the M1 chips -- UTM is a software specifically for macOS to run VMs or emulate other machines\n- How to create a new Ubuntu VM:\n    - Install the 22.04 live server arm64 ISO image\n    - Start \u003e Virtualize \u003e Other and select the ISO image\n    - Create a new NVMe drive for 20GB\n    - Go through Ubuntu setup\n- Installing GNOME desktop environment\n    - `sudo apt update \u0026\u0026 sudo apt upgrade`\n    - `sudo apt install ubuntu-gnome-desktop`\n    - `reboot`\n\nArticles that I used:\n- https://bytexd.com/how-to-install-gnome-desktop-in-ubuntu/\n- the beginning of this video https://youtu.be/GjqeoC267FM\n- the middle of this video https://youtu.be/hnwK-nkXolc","lastmodified":"2022-08-28T03:22:22.605483999Z","tags":null}}